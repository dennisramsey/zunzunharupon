import { getPluginType, getPluginOptions, sanitizeUrl, usePlateEditorRef, usePlateEditorState, someNode, createStore, createPrimitiveComponent, usePlateSelection, findNode, getEditorString, insertNodes, withoutNormalizing, getAboveNode, splitNodes, isElement, unwrapNodes, replaceNodeChildren, wrapNodes, isDefined, setNodes, isExpanded, removeNodes, getNodeProps, getNodeLeaf, focusEditor, useHotkeys, usePlateReadOnly, usePlateSelectors, getStartPoint, getEndPoint, isRangeAcrossBlocks, useOnClickOutside, useComposedRef, isCollapsed, isStartPoint, getPreviousNodeEndPoint, isEndPoint, getNextNodeStartPoint, select, mockPlugin, getRangeBefore, getRangeFromBlockStart, collapseSelection, createPluginFactory, isUrl } from '@udecode/plate-common';
import { withRemoveEmptyNodes } from '@udecode/plate-normalizers';
import { Path } from 'slate';
import { useRef, useState, useEffect, useCallback, useMemo } from 'react';
import { useVirtualFloating, getRangeBoundingClientRect, getDefaultBoundingClientRect, getSelectionBoundingClientRect } from '@udecode/plate-floating';
import { useFocused } from 'slate-react';

const createLinkNode = (editor, {
  url,
  text = '',
  target,
  children
}) => {
  const type = getPluginType(editor, ELEMENT_LINK);
  return {
    type,
    url,
    target,
    children: children !== null && children !== void 0 ? children : [{
      text
    }]
  };
};

const getLinkAttributes = (editor, link) => {
  const {
    allowedSchemes,
    defaultLinkAttributes,
    dangerouslySkipSanitization
  } = getPluginOptions(editor, ELEMENT_LINK);
  const attributes = {
    ...defaultLinkAttributes
  };
  const href = dangerouslySkipSanitization ? link.url : sanitizeUrl(link.url, {
    allowedSchemes
  }) || undefined;

  // Avoid passing `undefined` for href or target
  if (href !== undefined) {
    attributes.href = href;
  }
  if ('target' in link) {
    attributes.target = link.target;
  }
  return attributes;
};

const useLink = ({
  element
}) => {
  const editor = usePlateEditorRef();
  return {
    props: {
      ...getLinkAttributes(editor, element),
      // quick fix: hovering <a> with href loses the editor focus
      onMouseOver: e => {
        e.stopPropagation();
      }
    }
  };
};

const useLinkToolbarButtonState = () => {
  const editor = usePlateEditorState();
  const pressed = !!(editor !== null && editor !== void 0 && editor.selection) && someNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_LINK)
    }
  });
  return {
    pressed
  };
};
const useLinkToolbarButton = state => {
  const editor = usePlateEditorRef();
  return {
    props: {
      pressed: state.pressed,
      onClick: e => {
        e.preventDefault();
        e.stopPropagation();
        triggerFloatingLink(editor, {
          focused: true
        });
      }
    }
  };
};

const floatingLinkStore = createStore('floatingLink')({
  openEditorId: null,
  mouseDown: false,
  updated: false,
  url: '',
  text: '',
  newTab: false,
  mode: '',
  isEditing: false
}).extendActions(set => ({
  reset: () => {
    set.url('');
    set.text('');
    set.newTab(false);
    set.mode('');
    set.isEditing(false);
  }
})).extendActions(set => ({
  show: (mode, editorId) => {
    set.mode(mode);
    set.isEditing(false);
    set.openEditorId(editorId);
  },
  hide: () => {
    set.openEditorId(null);
    set.reset();
  }
})).extendSelectors(state => ({
  isOpen: editorId => state.openEditorId === editorId
}));
const floatingLinkActions = floatingLinkStore.set;
const floatingLinkSelectors = floatingLinkStore.get;
const useFloatingLinkSelectors = () => floatingLinkStore.use;

const useFloatingLinkNewTabInputState = () => {
  const updated = useFloatingLinkSelectors().updated();
  const ref = useRef(null);
  const [checked, setChecked] = useState(floatingLinkSelectors.newTab());
  useEffect(() => {
    if (ref.current && updated) {
      setTimeout(() => {
        var _ref$current;
        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();
      }, 0);
    }
  }, [updated]);
  return {
    ref,
    checked,
    setChecked
  };
};
const useFloatingLinkNewTabInput = ({
  checked,
  ref,
  setChecked
}) => {
  const onChange = useCallback(e => {
    setChecked(e.target.checked);
    floatingLinkActions.newTab(e.target.checked);
  }, [setChecked]);
  return {
    ref,
    props: {
      onChange,
      checked,
      type: 'checkbox'
    }
  };
};
const FloatingLinkNewTabInput = createPrimitiveComponent('input')({
  propsHook: useFloatingLinkNewTabInput,
  stateHook: useFloatingLinkNewTabInputState
});

const useFloatingLinkUrlInputState = () => {
  const updated = useFloatingLinkSelectors().updated();
  const ref = useRef(null);
  useEffect(() => {
    if (ref.current && updated) {
      setTimeout(() => {
        var _ref$current;
        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();
      }, 0);
    }
  }, [updated]);
  return {
    ref
  };
};
const useFloatingLinkUrlInput = state => {
  const onChange = useCallback(e => {
    floatingLinkActions.url(e.target.value);
  }, []);
  return {
    ref: state.ref,
    props: {
      onChange,
      defaultValue: floatingLinkSelectors.url()
    }
  };
};
const FloatingLinkUrlInput = createPrimitiveComponent('input')({
  propsHook: useFloatingLinkUrlInput,
  stateHook: useFloatingLinkUrlInputState
});

const useLinkOpenButtonState = () => {
  const editor = usePlateEditorRef();
  const selection = usePlateSelection();
  const entry = useMemo(() => findNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_LINK)
    }
  }),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [editor, selection]);
  if (!entry) {
    return {};
  }
  const [element] = entry;
  return {
    element
  };
};
const useLinkOpenButton = ({
  element
}) => {
  const editor = usePlateEditorRef();
  if (!element) {
    return {
      props: {}
    };
  }
  const linkAttributes = getLinkAttributes(editor, element);
  return {
    props: {
      ...linkAttributes,
      target: '_blank',
      'aria-label': 'Open link in a new tab',
      onMouseOver: e => {
        e.stopPropagation();
      }
    }
  };
};
const LinkOpenButton = createPrimitiveComponent('a')({
  stateHook: useLinkOpenButtonState,
  propsHook: useLinkOpenButton
});

const triggerFloatingLinkEdit = editor => {
  const entry = findNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_LINK)
    }
  });
  if (!entry) return;
  const [link, path] = entry;
  let text = getEditorString(editor, path);
  floatingLinkActions.url(link.url);
  floatingLinkActions.newTab(link.target === '_blank');
  if (text === link.url) {
    text = '';
  }
  floatingLinkActions.text(text);
  floatingLinkActions.isEditing(true);
  return true;
};

/**
 * Insert a link node.
 */
const insertLink = (editor, createLinkNodeOptions, options) => {
  insertNodes(editor, [createLinkNode(editor, createLinkNodeOptions)], options);
};

/**
 * Unwrap link node.
 */
const unwrapLink = (editor, options) => {
  return withoutNormalizing(editor, () => {
    if (options !== null && options !== void 0 && options.split) {
      var _editor$selection, _editor$selection4;
      const linkAboveAnchor = getAboveNode(editor, {
        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor,
        match: {
          type: getPluginType(editor, ELEMENT_LINK)
        }
      });

      // anchor in link
      if (linkAboveAnchor) {
        var _editor$selection2, _editor$selection3;
        splitNodes(editor, {
          at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.anchor,
          match: n => isElement(n) && n.type === getPluginType(editor, ELEMENT_LINK)
        });
        unwrapLink(editor, {
          at: (_editor$selection3 = editor.selection) === null || _editor$selection3 === void 0 ? void 0 : _editor$selection3.anchor
        });
        return true;
      }
      const linkAboveFocus = getAboveNode(editor, {
        at: (_editor$selection4 = editor.selection) === null || _editor$selection4 === void 0 ? void 0 : _editor$selection4.focus,
        match: {
          type: getPluginType(editor, ELEMENT_LINK)
        }
      });

      // focus in link
      if (linkAboveFocus) {
        var _editor$selection5, _editor$selection6;
        splitNodes(editor, {
          at: (_editor$selection5 = editor.selection) === null || _editor$selection5 === void 0 ? void 0 : _editor$selection5.focus,
          match: n => isElement(n) && n.type === getPluginType(editor, ELEMENT_LINK)
        });
        unwrapLink(editor, {
          at: (_editor$selection6 = editor.selection) === null || _editor$selection6 === void 0 ? void 0 : _editor$selection6.focus
        });
        return true;
      }
    }
    unwrapNodes(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_LINK)
      },
      ...options
    });
  });
};

/**
 * If the text is different than the link above text, replace link children by a new text.
 * The new text has the same marks than the first text replaced.
 */
const upsertLinkText = (editor, {
  text
}) => {
  const newLink = getAboveNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_LINK)
    }
  });
  if (newLink) {
    const [newLinkNode, newLinkPath] = newLink;
    if (text !== null && text !== void 0 && text.length && text !== getEditorString(editor, newLinkPath)) {
      const firstText = newLinkNode.children[0];

      // remove link children
      replaceNodeChildren(editor, {
        at: newLinkPath,
        nodes: {
          ...firstText,
          text
        },
        insertOptions: {
          select: true
        }
      });
    }
  }
};

/**
 * Wrap a link node with split.
 */
const wrapLink = (editor, {
  url,
  target,
  ...options
}) => {
  wrapNodes(editor, {
    type: getPluginType(editor, ELEMENT_LINK),
    url,
    target,
    children: []
  }, {
    split: true,
    ...options
  });
};

/**
 * If selection in a link or is not url:
 * - insert text with url, exit
 * If selection is expanded or `update` in a link:
 * - remove link node, get link text
 * Then:
 * - insert link node
 */
const upsertLink = (editor, {
  url,
  text,
  target,
  insertTextInLink,
  insertNodesOptions,
  skipValidation = false
}) => {
  var _text, _editor$selection, _text2;
  const at = editor.selection;
  if (!at) return;
  const linkAbove = getAboveNode(editor, {
    at,
    match: {
      type: getPluginType(editor, ELEMENT_LINK)
    }
  });

  // anchor and focus in link -> insert text
  if (insertTextInLink && linkAbove) {
    // we don't want to insert marks in links
    editor.insertText(url);
    return true;
  }
  if (!skipValidation && !validateUrl(editor, url)) return;
  if (isDefined(text) && text.length === 0) {
    text = url;
  }

  // edit the link url and/or target
  if (linkAbove) {
    var _linkAbove$, _linkAbove$2;
    if (url !== ((_linkAbove$ = linkAbove[0]) === null || _linkAbove$ === void 0 ? void 0 : _linkAbove$.url) || target !== ((_linkAbove$2 = linkAbove[0]) === null || _linkAbove$2 === void 0 ? void 0 : _linkAbove$2.target)) {
      setNodes(editor, {
        url,
        target
      }, {
        at: linkAbove[1]
      });
    }
    upsertLinkText(editor, {
      url,
      text,
      target
    });
    return true;
  }

  // selection contains at one edge edge or between the edges
  const linkEntry = findNode(editor, {
    at,
    match: {
      type: getPluginType(editor, ELEMENT_LINK)
    }
  });
  const [linkNode, linkPath] = linkEntry !== null && linkEntry !== void 0 ? linkEntry : [];
  let shouldReplaceText = false;
  if (linkPath && (_text = text) !== null && _text !== void 0 && _text.length) {
    const linkText = getEditorString(editor, linkPath);
    if (text !== linkText) {
      shouldReplaceText = true;
    }
  }
  if (isExpanded(at)) {
    // anchor and focus in link
    if (linkAbove) {
      unwrapLink(editor, {
        at: linkAbove[1]
      });
    } else {
      unwrapLink(editor, {
        split: true
      });
    }
    wrapLink(editor, {
      url,
      target
    });
    upsertLinkText(editor, {
      url,
      target,
      text
    });
    return true;
  }
  if (shouldReplaceText) {
    removeNodes(editor, {
      at: linkPath
    });
  }
  const props = getNodeProps(linkNode !== null && linkNode !== void 0 ? linkNode : {});
  const path = (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus.path;
  if (!path) return;

  // link text should have the focused leaf marks
  const leaf = getNodeLeaf(editor, path);

  // if text is empty, text is url
  if (!((_text2 = text) !== null && _text2 !== void 0 && _text2.length)) {
    text = url;
  }
  insertLink(editor, {
    ...props,
    url,
    target,
    children: [{
      ...leaf,
      text
    }]
  }, insertNodesOptions);
  return true;
};

/**
 * Insert link if url is valid.
 * Text is url if empty.
 * Close floating link.
 * Focus editor.
 */
const submitFloatingLink = editor => {
  if (!editor.selection) return;
  const {
    forceSubmit
  } = getPluginOptions(editor, ELEMENT_LINK);
  const url = floatingLinkSelectors.url();
  if (!forceSubmit && !validateUrl(editor, url)) return;
  const text = floatingLinkSelectors.text();
  const target = floatingLinkSelectors.newTab() ? '_blank' : undefined;
  floatingLinkActions.hide();
  upsertLink(editor, {
    url,
    text,
    target,
    skipValidation: true
  });
  setTimeout(() => {
    focusEditor(editor, editor.selection);
  }, 0);
  return true;
};

const useFloatingLinkEnter = () => {
  const editor = usePlateEditorRef();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  useHotkeys('*', e => {
    if (e.key !== 'Enter') return;
    if (submitFloatingLink(editor)) {
      e.preventDefault();
    }
  }, {
    enabled: open,
    enableOnFormTags: ['INPUT']
  }, []);
};

const useFloatingLinkEscape = () => {
  const editor = usePlateEditorRef();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  useHotkeys('escape', e => {
    if (!floatingLinkSelectors.mode()) return;
    e.preventDefault();
    if (floatingLinkSelectors.mode() === 'edit' && floatingLinkSelectors.isEditing()) {
      floatingLinkActions.show('edit', editor.id);
      focusEditor(editor, editor.selection);
      return;
    }
    if (floatingLinkSelectors.mode() === 'insert') {
      focusEditor(editor, editor.selection);
    }
    floatingLinkActions.hide();
  }, {
    enabled: open,
    enableOnFormTags: ['INPUT'],
    enableOnContentEditable: true
  }, []);
};

const useVirtualFloatingLink = ({
  editorId,
  ...floatingOptions
}) => {
  return useVirtualFloating({
    onOpenChange: open => floatingLinkActions.openEditorId(open ? editorId : null),
    ...floatingOptions
  });
};

const useFloatingLinkEditState = ({
  floatingOptions
} = {}) => {
  const editor = usePlateEditorRef();
  const {
    triggerFloatingLinkHotkeys
  } = getPluginOptions(editor, ELEMENT_LINK);
  const readOnly = usePlateReadOnly();
  const isEditing = useFloatingLinkSelectors().isEditing();
  const keyEditor = usePlateSelectors().keyEditor();
  const mode = useFloatingLinkSelectors().mode();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  const getBoundingClientRect = useCallback(() => {
    const entry = getAboveNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_LINK)
      }
    });
    if (entry) {
      const [, path] = entry;
      return getRangeBoundingClientRect(editor, {
        anchor: getStartPoint(editor, path),
        focus: getEndPoint(editor, path)
      });
    }
    return getDefaultBoundingClientRect();
  }, [editor]);
  const isOpen = open && mode === 'edit';
  const floating = useVirtualFloatingLink({
    editorId: editor.id,
    open: isOpen,
    getBoundingClientRect,
    ...floatingOptions
  });
  return {
    editor,
    triggerFloatingLinkHotkeys,
    isOpen,
    floating,
    keyEditor,
    isEditing,
    readOnly
  };
};
const useFloatingLinkEdit = ({
  editor,
  triggerFloatingLinkHotkeys,
  keyEditor,
  floating,
  isOpen,
  readOnly
}) => {
  useEffect(() => {
    if (editor.selection && someNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_LINK)
      }
    })) {
      floatingLinkActions.show('edit', editor.id);
      floating.update();
      return;
    }
    if (floatingLinkSelectors.mode() === 'edit') {
      floatingLinkActions.hide();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [editor, keyEditor, floating.update]);
  useHotkeys(triggerFloatingLinkHotkeys, e => {
    if (floatingLinkSelectors.mode() === 'edit' && triggerFloatingLinkEdit(editor)) {
      e.preventDefault();
    }
  }, {
    enableOnContentEditable: true
  }, []);
  useFloatingLinkEnter();
  useFloatingLinkEscape();
  return {
    ref: floating.refs.setFloating,
    props: {
      style: {
        ...floating.style,
        zIndex: 1
      }
    },
    editButtonProps: {
      onClick: useCallback(() => {
        triggerFloatingLinkEdit(editor);
      }, [editor])
    },
    unlinkButtonProps: {
      onClick: useCallback(() => {
        unwrapLink(editor);
        focusEditor(editor, editor.selection);
      }, [editor])
    }
  };
};

/**
 * Trigger floating link.
 *
 * Do not trigger when:
 * - selection is across blocks
 * - selection has more than one leaf node
 * - lowest selection is not text
 * - selection has a link node
 */
const triggerFloatingLinkInsert = (editor, {
  focused
} = {}) => {
  if (floatingLinkSelectors.mode()) return;
  if (!focused) return;
  if (isRangeAcrossBlocks(editor, {
    at: editor.selection
  })) return;
  const hasLink = someNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_LINK)
    }
  });
  if (hasLink) return;
  floatingLinkActions.text(getEditorString(editor, editor.selection));
  floatingLinkActions.show('insert', editor.id);
  return true;
};

const useFloatingLinkInsertState = ({
  floatingOptions
} = {}) => {
  const editor = usePlateEditorRef();
  const {
    triggerFloatingLinkHotkeys
  } = getPluginOptions(editor, ELEMENT_LINK);
  const readOnly = usePlateReadOnly();
  const focused = useFocused();
  const mode = useFloatingLinkSelectors().mode();
  const isOpen = useFloatingLinkSelectors().isOpen(editor.id);
  const floating = useVirtualFloatingLink({
    editorId: editor.id,
    open: isOpen && mode === 'insert',
    getBoundingClientRect: getSelectionBoundingClientRect,
    whileElementsMounted: () => {},
    ...floatingOptions
  });
  return {
    editor,
    triggerFloatingLinkHotkeys,
    floating,
    focused,
    isOpen,
    readOnly
  };
};
const useFloatingLinkInsert = ({
  editor,
  triggerFloatingLinkHotkeys,
  floating,
  focused,
  isOpen,
  readOnly
}) => {
  const onChange = useCallback(e => {
    floatingLinkActions.text(e.target.value);
  }, []);
  const ref = useOnClickOutside(() => {
    if (floatingLinkSelectors.mode() === 'insert') {
      floatingLinkActions.hide();
      focusEditor(editor, editor.selection);
    }
  }, {
    disabled: !isOpen
  });

  // wait for update before focusing input
  useEffect(() => {
    if (isOpen) {
      floating.update();
      floatingLinkActions.updated(true);
    } else {
      floatingLinkActions.updated(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen, floating.update]);
  useHotkeys(triggerFloatingLinkHotkeys, e => {
    if (triggerFloatingLinkInsert(editor, {
      focused
    })) {
      e.preventDefault();
    }
  }, {
    enableOnContentEditable: true
  }, [focused]);
  useFloatingLinkEscape();
  return {
    ref: useComposedRef(floating.refs.setFloating, ref),
    props: {
      style: {
        ...floating.style,
        zIndex: 1
      }
    },
    hidden: readOnly,
    textInputProps: {
      onChange,
      defaultValue: floatingLinkSelectors.text()
    }
  };
};

const triggerFloatingLink = (editor, {
  focused
} = {}) => {
  if (floatingLinkSelectors.mode() === 'edit') {
    triggerFloatingLinkEdit(editor);
    return;
  }
  triggerFloatingLinkInsert(editor, {
    focused
  });
};

const validateUrl = (editor, url) => {
  const {
    allowedSchemes,
    isUrl,
    dangerouslySkipSanitization
  } = getPluginOptions(editor, ELEMENT_LINK);
  if (isUrl && !isUrl(url)) return false;
  if (!dangerouslySkipSanitization && !sanitizeUrl(url, {
    allowedSchemes,
    permitInvalid: true
  })) return false;
  return true;
};

/**
 * Insert space after a url to wrap a link.
 * Lookup from the block start to the cursor to check if there is an url.
 * If not found, lookup before the cursor for a space character to check the url.
 *
 * On insert data:
 * Paste a string inside a link element will edit its children text but not its url.
 *
 */

const withLink = (editor, {
  type,
  options: {
    isUrl,
    getUrlHref,
    rangeBeforeOptions,
    keepSelectedTextOnPaste
  }
}) => {
  const {
    insertData,
    insertText,
    apply,
    normalizeNode,
    insertBreak
  } = editor;
  const wrapLink = () => {
    withoutNormalizing(editor, () => {
      var _getUrlHref;
      const selection = editor.selection;

      // get the range from first space before the cursor
      let beforeWordRange = getRangeBefore(editor, selection, rangeBeforeOptions);

      // if no space found before, get the range from block start
      if (!beforeWordRange) {
        beforeWordRange = getRangeFromBlockStart(editor);
      }

      // if no word found before the cursor, exit
      if (!beforeWordRange) return;
      const hasLink = someNode(editor, {
        at: beforeWordRange,
        match: {
          type: getPluginType(editor, ELEMENT_LINK)
        }
      });

      // if word before the cursor has a link, exit
      if (hasLink) return;
      let beforeWordText = getEditorString(editor, beforeWordRange);
      beforeWordText = (_getUrlHref = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(beforeWordText)) !== null && _getUrlHref !== void 0 ? _getUrlHref : beforeWordText;

      // if word before is not an url, exit
      if (!isUrl(beforeWordText)) return;

      // select the word to wrap link
      select(editor, beforeWordRange);

      // wrap link
      upsertLink(editor, {
        url: beforeWordText
      });

      // collapse selection
      collapseSelection(editor, {
        edge: 'end'
      });
    });
  };
  editor.insertBreak = () => {
    if (!isCollapsed(editor.selection)) return insertBreak();
    wrapLink();
    insertBreak();
  };
  editor.insertText = text => {
    if (text === ' ' && isCollapsed(editor.selection)) {
      wrapLink();
    }
    insertText(text);
  };
  editor.insertData = data => {
    const text = data.getData('text/plain');
    const textHref = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(text);
    if (text) {
      const value = textHref || text;
      const inserted = upsertLink(editor, {
        text: keepSelectedTextOnPaste ? undefined : value,
        url: value,
        insertTextInLink: true
      });
      if (inserted) return;
    }
    insertData(data);
  };

  // TODO: plugin
  editor.apply = operation => {
    if (operation.type === 'set_selection') {
      const range = operation.newProperties;
      if (range && range.focus && range.anchor && isCollapsed(range)) {
        const entry = getAboveNode(editor, {
          at: range,
          match: {
            type: getPluginType(editor, ELEMENT_LINK)
          }
        });
        if (entry) {
          const [, path] = entry;
          let newPoint;
          if (isStartPoint(editor, range.focus, path)) {
            newPoint = getPreviousNodeEndPoint(editor, path);
          }
          if (isEndPoint(editor, range.focus, path)) {
            newPoint = getNextNodeStartPoint(editor, path);
          }
          if (newPoint) {
            operation.newProperties = {
              anchor: newPoint,
              focus: newPoint
            };
          }
        }
      }
    }
    apply(operation);
  };

  // TODO: plugin
  editor.normalizeNode = ([node, path]) => {
    if (node.type === getPluginType(editor, ELEMENT_LINK)) {
      const range = editor.selection;
      if (range && isCollapsed(range) && isEndPoint(editor, range.focus, path)) {
        const nextPoint = getNextNodeStartPoint(editor, path);

        // select next text node if any
        if (nextPoint) {
          select(editor, nextPoint);
        } else {
          // insert text node then select
          const nextPath = Path.next(path);
          insertNodes(editor, {
            text: ''
          }, {
            at: nextPath
          });
          select(editor, nextPath);
        }
      }
    }
    normalizeNode([node, path]);
  };
  editor = withRemoveEmptyNodes(editor, mockPlugin({
    options: {
      types: type
    }
  }));
  return editor;
};

const ELEMENT_LINK = 'a';
/**
 * Enables support for hyperlinks.
 */
const createLinkPlugin = createPluginFactory({
  key: ELEMENT_LINK,
  isElement: true,
  isInline: true,
  withOverrides: withLink,
  options: {
    allowedSchemes: ['http', 'https', 'mailto', 'tel'],
    dangerouslySkipSanitization: false,
    defaultLinkAttributes: {},
    isUrl,
    rangeBeforeOptions: {
      matchString: ' ',
      skipInvalid: true,
      afterMatch: true
    },
    triggerFloatingLinkHotkeys: 'meta+k, ctrl+k',
    keepSelectedTextOnPaste: true
  },
  then: (editor, {
    type
  }) => ({
    props: ({
      element
    }) => ({
      nodeProps: getLinkAttributes(editor, element)
    }),
    deserializeHtml: {
      rules: [{
        validNodeName: 'A'
      }],
      getNode: el => {
        const url = el.getAttribute('href');
        if (url && validateUrl(editor, url)) {
          return {
            type,
            url,
            target: el.getAttribute('target') || '_blank'
          };
        }
      }
    }
  })
});

export { ELEMENT_LINK, FloatingLinkNewTabInput, FloatingLinkUrlInput, LinkOpenButton, createLinkNode, createLinkPlugin, floatingLinkActions, floatingLinkSelectors, floatingLinkStore, getLinkAttributes, insertLink, submitFloatingLink, triggerFloatingLink, triggerFloatingLinkEdit, triggerFloatingLinkInsert, unwrapLink, upsertLink, upsertLinkText, useFloatingLinkEdit, useFloatingLinkEditState, useFloatingLinkEnter, useFloatingLinkEscape, useFloatingLinkInsert, useFloatingLinkInsertState, useFloatingLinkNewTabInput, useFloatingLinkNewTabInputState, useFloatingLinkSelectors, useFloatingLinkUrlInput, useFloatingLinkUrlInputState, useLink, useLinkOpenButton, useLinkOpenButtonState, useLinkToolbarButton, useLinkToolbarButtonState, useVirtualFloatingLink, validateUrl, withLink, wrapLink };
//# sourceMappingURL=index.es.js.map
