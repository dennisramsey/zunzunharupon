'use strict';

var plateCommon = require('@udecode/plate-common');
var react = require('react');
var slateReact = require('slate-react');
var videoParser = require('js-video-url-parser');

const insertImage = (editor, url, options = {}) => {
  const text = {
    text: ''
  };
  const image = {
    type: plateCommon.getPluginType(editor, ELEMENT_IMAGE),
    url: url,
    children: [text]
  };
  plateCommon.insertNodes(editor, image, {
    nextBlock: true,
    ...options
  });
};

const imageExtensions = new Set(['ase', 'art', 'bmp', 'blp', 'cd5', 'cit', 'cpt', 'cr2', 'cut', 'dds', 'dib', 'djvu', 'egt', 'exif', 'gif', 'gpl', 'grf', 'icns', 'ico', 'iff', 'jng', 'jpeg', 'jpg', 'jfif', 'jp2', 'jps', 'lbm', 'max', 'miff', 'mng', 'msp', 'nitf', 'ota', 'pbm', 'pc1', 'pc2', 'pc3', 'pcf', 'pcx', 'pdn', 'pgm', 'PI1', 'PI2', 'PI3', 'pict', 'pct', 'pnm', 'pns', 'ppm', 'psb', 'psd', 'pdd', 'psp', 'px', 'pxm', 'pxr', 'qfx', 'raw', 'rle', 'sct', 'sgi', 'rgb', 'int', 'bw', 'tga', 'tiff', 'tif', 'vtf', 'xbm', 'xcf', 'xpm', '3dv', 'amf', 'ai', 'awg', 'cgm', 'cdr', 'cmx', 'dxf', 'e2d', 'egt', 'eps', 'fs', 'gbr', 'odg', 'svg', 'stl', 'vrml', 'x3d', 'sxd', 'v2d', 'vnd', 'wmf', 'emf', 'art', 'xar', 'png', 'webp', 'jxr', 'hdp', 'wdp', 'cur', 'ecw', 'iff', 'lbm', 'liff', 'nrrd', 'pam', 'pcx', 'pgf', 'sgi', 'rgb', 'rgba', 'bw', 'int', 'inta', 'sid', 'ras', 'sun', 'tga']);
const isImageUrl = url => {
  if (!plateCommon.isUrl(url)) return false;
  const ext = new URL(url).pathname.split('.').pop();
  return imageExtensions.has(ext);
};

/**
 * If inserted text is image url, insert image instead.
 */
const withImageEmbed = (editor, plugin) => {
  const {
    insertData
  } = editor;
  editor.insertData = dataTransfer => {
    const text = dataTransfer.getData('text/plain');
    if (isImageUrl(text)) {
      insertImage(editor, text);
      return;
    }
    insertData(dataTransfer);
  };
  return editor;
};

/**
 * Allows for pasting images from clipboard.
 * Not yet: dragging and dropping images, selecting them through a file system dialog.
 */
const withImageUpload = (editor, plugin) => {
  const {
    options: {
      uploadImage
    }
  } = plugin;
  const {
    insertData
  } = editor;
  editor.insertData = dataTransfer => {
    const text = dataTransfer.getData('text/plain');
    const {
      files
    } = dataTransfer;
    if (!text && files && files.length > 0) {
      const injectedPlugins = plateCommon.getInjectedPlugins(editor, plugin);
      if (!plateCommon.pipeInsertDataQuery(injectedPlugins, {
        data: text,
        dataTransfer
      })) {
        return insertData(dataTransfer);
      }
      for (const file of files) {
        const reader = new FileReader();
        const [mime] = file.type.split('/');
        if (mime === 'image') {
          reader.addEventListener('load', async () => {
            if (!reader.result) {
              return;
            }
            const uploadedUrl = uploadImage ? await uploadImage(reader.result) : reader.result;
            insertImage(editor, uploadedUrl);
          });
          reader.readAsDataURL(file);
        }
      }
    } else {
      insertData(dataTransfer);
    }
  };
  return editor;
};

/**
 * @see withImageUpload
 * @see withImageEmbed
 */
const withImage = (editor, plugin) => {
  const {
    options: {
      disableUploadInsert,
      disableEmbedInsert
    }
  } = plugin;
  if (!disableUploadInsert) {
    editor = withImageUpload(editor, plugin);
  }
  if (!disableEmbedInsert) {
    editor = withImageEmbed(editor);
  }
  return editor;
};

const ELEMENT_IMAGE = 'img';

/**
 * Enables support for images.
 */
const createImagePlugin = plateCommon.createPluginFactory({
  key: ELEMENT_IMAGE,
  isElement: true,
  isVoid: true,
  withOverrides: withImage,
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: 'IMG'
      }],
      getNode: el => ({
        type,
        url: el.getAttribute('src')
      })
    }
  })
});

const useImage = () => {
  const {
    url
  } = plateCommon.useElement();
  return {
    props: {
      src: url,
      draggable: true
    }
  };
};
const Image = plateCommon.createPrimitiveComponent('img')({
  propsHook: useImage
});

const insertMedia = async (editor, {
  getUrl,
  type = plateCommon.getPluginType(editor, ELEMENT_IMAGE)
} = {}) => {
  const url = getUrl ? await getUrl() : window.prompt(`Enter the URL of the ${type === ELEMENT_IMAGE ? ELEMENT_IMAGE : ELEMENT_MEDIA_EMBED}`);
  if (!url) return;
  if (type === plateCommon.getPluginType(editor, ELEMENT_IMAGE)) {
    insertImage(editor, url);
  } else {
    insertMediaEmbed(editor, {
      url
    });
  }
};

const ELEMENT_MEDIA = 'media';

const parseIframeUrl = url => {
  // if not starting with http, assume pasting of full iframe embed code
  if (url.slice(0, 4) !== 'http') {
    var _url$match, _src$match;
    const regexMatchSrc = /src=".*?"/;
    const regexGroupQuotes = /"([^"]*)"/;
    const src = (_url$match = url.match(regexMatchSrc)) === null || _url$match === void 0 ? void 0 : _url$match[0];
    const returnString = src === null || src === void 0 ? void 0 : (_src$match = src.match(regexGroupQuotes)) === null || _src$match === void 0 ? void 0 : _src$match[1];
    if (returnString) {
      url = returnString;
    }
  }
  return url;
};

const ELEMENT_MEDIA_EMBED = 'media_embed';

/**
 * Enables support for embeddable media such as YouTube
 * or Vimeo videos, Instagram posts and tweets or Google Maps.
 */
const createMediaEmbedPlugin = plateCommon.createPluginFactory({
  key: ELEMENT_MEDIA_EMBED,
  isElement: true,
  isVoid: true,
  options: {
    transformUrl: parseIframeUrl
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: 'IFRAME'
      }],
      getNode: el => {
        const url = el.getAttribute('src');
        if (url) {
          return {
            type,
            url
          };
        }
      }
    }
  })
});

const twitterRegex = /^https?:\/\/twitter\.com\/(?:#!\/)?(\w+)\/status(es)?\/(?<id>\d+)/;
const parseTwitterUrl = url => {
  if (url.match(twitterRegex)) {
    var _twitterRegex$exec, _twitterRegex$exec$gr;
    return {
      provider: 'twitter',
      id: (_twitterRegex$exec = twitterRegex.exec(url)) === null || _twitterRegex$exec === void 0 ? void 0 : (_twitterRegex$exec$gr = _twitterRegex$exec.groups) === null || _twitterRegex$exec$gr === void 0 ? void 0 : _twitterRegex$exec$gr.id,
      url
    };
  }
};

const YOUTUBE_PREFIX = 'https://www.youtube.com/embed/';
const VIMEO_PREFIX = 'https://player.vimeo.com/video/';
const DAILYMOTION_PREFIX = 'https://www.dailymotion.com/embed/video/';
const YOUKU_PREFIX = 'https://player.youku.com/embed/';
const COUB_PREFIX = 'https://coub.com/embed/';
const VIDEO_PROVIDERS = ['youtube', 'vimeo', 'dailymotion', 'youku', 'coub'];
const parseVideoUrl = url => {
  if (!plateCommon.isUrl(url)) return;
  const videoData = videoParser.parse(url);
  if (videoData !== null && videoData !== void 0 && videoData.provider && videoData.id) {
    const {
      id,
      provider
    } = videoData;
    const providerUrls = {
      youtube: `${YOUTUBE_PREFIX}${id}`,
      vimeo: `${VIMEO_PREFIX}${id}`,
      dailymotion: `${DAILYMOTION_PREFIX}${id}`,
      youku: `${YOUKU_PREFIX}${id}`,
      coub: `${COUB_PREFIX}${id}`
    };
    return {
      id,
      provider,
      url: providerUrls[provider]
    };
  }
};

const insertMediaEmbed = (editor, {
  url = '',
  key = ELEMENT_MEDIA_EMBED
}, options = {}) => {
  if (!editor.selection) return;
  const selectionParentEntry = plateCommon.getParentNode(editor, editor.selection);
  if (!selectionParentEntry) return;
  const [, path] = selectionParentEntry;
  plateCommon.insertNodes(editor, {
    type: key,
    url,
    children: [{
      text: ''
    }]
  }, {
    at: path,
    nextBlock: true,
    ...options
  });
};

const useMediaState = ({
  urlParsers
} = {}) => {
  const element = plateCommon.useElement();
  const focused = slateReact.useFocused();
  const selected = slateReact.useSelected();
  const readOnly = slateReact.useReadOnly();
  const {
    url,
    align
  } = element;
  const embed = react.useMemo(() => {
    if (!urlParsers) return;
    for (const parser of urlParsers) {
      const data = parser(url);
      if (data) {
        return data;
      }
    }
  }, [urlParsers, url]);
  const isTweet = (embed === null || embed === void 0 ? void 0 : embed.provider) === 'twitter';
  const isVideo = !!(embed !== null && embed !== void 0 && embed.provider) && VIDEO_PROVIDERS.includes(embed.provider);
  const isYoutube = (embed === null || embed === void 0 ? void 0 : embed.provider) === 'youtube';
  return {
    align,
    focused,
    selected,
    readOnly,
    embed,
    isTweet,
    isVideo,
    isYoutube
  };
};

const useMediaToolbarButton = ({
  nodeType
} = {}) => {
  const editor = plateCommon.usePlateEditorRef();
  return {
    props: {
      onClick: async () => {
        await insertMedia(editor, {
          type: nodeType
        });
        plateCommon.focusEditor(editor);
      }
    }
  };
};

const floatingMediaStore = plateCommon.createStore('floatingMedia')({
  url: '',
  isEditing: false
}).extendActions(set => ({
  reset: () => {
    set.url('');
    set.isEditing(false);
  }
}));
const floatingMediaActions = floatingMediaStore.set;
const floatingMediaSelectors = floatingMediaStore.get;
const useFloatingMediaSelectors = () => floatingMediaStore.use;

const useFloatingMediaEditButton = () => {
  const element = plateCommon.useElement();
  return {
    props: {
      onClick: react.useCallback(() => {
        floatingMediaActions.url(element.url);
        floatingMediaActions.isEditing(true);
      }, [element.url])
    }
  };
};
const FloatingMediaEditButton = plateCommon.createPrimitiveComponent('button')({
  propsHook: useFloatingMediaEditButton
});

const submitFloatingMedia = (editor, {
  element,
  pluginKey = ELEMENT_MEDIA
}) => {
  let url = floatingMediaSelectors.url();
  if (url === element.url) {
    floatingMediaActions.reset();
    return true;
  }
  const {
    isUrl: _isUrl = plateCommon.isUrl,
    transformUrl
  } = plateCommon.getPluginOptions(editor, pluginKey);
  const isValid = _isUrl(url);
  if (!isValid) return;
  if (transformUrl) {
    url = transformUrl(url);
  }
  plateCommon.setNodes(editor, {
    url
  });
  floatingMediaActions.reset();
  plateCommon.focusEditor(editor, editor.selection);
  return true;
};

const useFloatingMediaUrlInputState = ({
  pluginKey
} = {}) => {
  const editor = plateCommon.usePlateEditorRef();
  const element = plateCommon.useElement();
  plateCommon.useHotkeys('enter', e => {
    if (submitFloatingMedia(editor, {
      element,
      pluginKey
    })) {
      e.preventDefault();
    }
  }, {
    enableOnFormTags: ['INPUT']
  }, []);
  plateCommon.useHotkeys('escape', () => {
    if (floatingMediaSelectors.isEditing()) {
      floatingMediaActions.reset();
      plateCommon.focusEditor(editor, editor.selection);
    }
  }, {
    enableOnFormTags: ['INPUT'],
    enableOnContentEditable: true
  }, []);
  return {
    defaultValue: floatingMediaSelectors.url()
  };
};
const useFloatingMediaUrlInput = ({
  defaultValue
}) => {
  const onChange = react.useCallback(e => {
    floatingMediaActions.url(e.target.value);
  }, []);
  return {
    props: {
      onChange,
      autoFocus: true,
      defaultValue
    }
  };
};
const FloatingMediaUrlInput = plateCommon.createPrimitiveComponent('input')({
  stateHook: useFloatingMediaUrlInputState,
  propsHook: useFloatingMediaUrlInput
});

const FloatingMedia = {
  EditButton: FloatingMediaEditButton,
  UrlInput: FloatingMediaUrlInput
};

exports.ELEMENT_IMAGE = ELEMENT_IMAGE;
exports.ELEMENT_MEDIA = ELEMENT_MEDIA;
exports.ELEMENT_MEDIA_EMBED = ELEMENT_MEDIA_EMBED;
exports.FloatingMedia = FloatingMedia;
exports.FloatingMediaEditButton = FloatingMediaEditButton;
exports.FloatingMediaUrlInput = FloatingMediaUrlInput;
exports.Image = Image;
exports.VIDEO_PROVIDERS = VIDEO_PROVIDERS;
exports.createImagePlugin = createImagePlugin;
exports.createMediaEmbedPlugin = createMediaEmbedPlugin;
exports.floatingMediaActions = floatingMediaActions;
exports.floatingMediaSelectors = floatingMediaSelectors;
exports.floatingMediaStore = floatingMediaStore;
exports.insertImage = insertImage;
exports.insertMedia = insertMedia;
exports.insertMediaEmbed = insertMediaEmbed;
exports.isImageUrl = isImageUrl;
exports.parseIframeUrl = parseIframeUrl;
exports.parseTwitterUrl = parseTwitterUrl;
exports.parseVideoUrl = parseVideoUrl;
exports.submitFloatingMedia = submitFloatingMedia;
exports.useFloatingMediaEditButton = useFloatingMediaEditButton;
exports.useFloatingMediaSelectors = useFloatingMediaSelectors;
exports.useFloatingMediaUrlInput = useFloatingMediaUrlInput;
exports.useFloatingMediaUrlInputState = useFloatingMediaUrlInputState;
exports.useImage = useImage;
exports.useMediaState = useMediaState;
exports.useMediaToolbarButton = useMediaToolbarButton;
exports.withImage = withImage;
exports.withImageEmbed = withImageEmbed;
exports.withImageUpload = withImageUpload;
//# sourceMappingURL=index.js.map
