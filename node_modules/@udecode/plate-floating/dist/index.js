'use strict';

var react$1 = require('react');
var plateCommon = require('@udecode/plate-common');
var slateReact = require('slate-react');
var react = require('@floating-ui/react');
var slate = require('slate');
var reactDropdownMenu = require('@radix-ui/react-dropdown-menu');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var reactDropdownMenu__namespace = /*#__PURE__*/_interopNamespaceDefault(reactDropdownMenu);

const getDefaultBoundingClientRect = () => ({
  width: 0,
  height: 0,
  x: 0,
  y: 0,
  top: -9999,
  left: -9999,
  right: 9999,
  bottom: 9999
});
const createVirtualElement = () => ({
  getBoundingClientRect: getDefaultBoundingClientRect
});

const useFloatingToolbarState = ({
  floatingOptions,
  hideToolbar,
  ignoreReadOnly
}) => {
  const editor = plateCommon.usePlateEditorState();
  const focusedEditorId = plateCommon.useEventEditorSelectors.focus();
  const focused = slateReact.useFocused();
  const [open, setOpen] = react$1.useState(false);
  const [waitForCollapsedSelection, setWaitForCollapsedSelection] = react$1.useState(false);
  const selectionExpanded = editor && plateCommon.isSelectionExpanded(editor);
  const selectionText = editor && plateCommon.getSelectionText(editor);
  const floating = useVirtualFloating(plateCommon.mergeProps({
    getBoundingClientRect: getSelectionBoundingClientRect,
    open,
    onOpenChange: setOpen
  }, floatingOptions));
  return {
    editor,
    open,
    setOpen,
    waitForCollapsedSelection,
    setWaitForCollapsedSelection,
    selectionExpanded,
    selectionText,
    focused,
    focusedEditorId,
    ignoreReadOnly,
    hideToolbar,
    floating
  };
};
const useFloatingToolbar = ({
  editor,
  selectionExpanded,
  selectionText,
  waitForCollapsedSelection,
  setWaitForCollapsedSelection,
  open,
  setOpen,
  focused,
  focusedEditorId,
  floating,
  ignoreReadOnly,
  hideToolbar
}) => {
  var _selectionText$length;
  // On refocus, the editor keeps the previous selection,
  // so we need to wait it's collapsed at the new position before displaying the floating toolbar.
  react$1.useEffect(() => {
    if (!focused || ignoreReadOnly) {
      setWaitForCollapsedSelection(true);
    }
    if (!selectionExpanded) {
      setWaitForCollapsedSelection(false);
    }
  }, [focused, ignoreReadOnly, selectionExpanded, setWaitForCollapsedSelection]);
  react$1.useEffect(() => {
    if (!selectionExpanded || !selectionText || !(editor.id === focusedEditorId || ignoreReadOnly) && hideToolbar) {
      setOpen(false);
    } else if (selectionText && selectionExpanded && !waitForCollapsedSelection) {
      setOpen(true);
    }
  }, [setOpen, editor.id, editor.selection, focusedEditorId, hideToolbar, ignoreReadOnly, selectionExpanded, selectionText, waitForCollapsedSelection]);
  const {
    update
  } = floating;
  const selectionTextLength = (_selectionText$length = selectionText === null || selectionText === void 0 ? void 0 : selectionText.length) !== null && _selectionText$length !== void 0 ? _selectionText$length : 0;
  react$1.useEffect(() => {
    if (selectionTextLength > 0) {
      update === null || update === void 0 ? void 0 : update();
    }
  }, [selectionTextLength, update]);
  return {
    ref: floating.refs.setFloating,
    props: {
      style: floating.style
    },
    hidden: !open
  };
};

const makeClientRect = ({
  top,
  bottom,
  left,
  right
}) => {
  const width = right - left;
  const height = bottom - top;
  const props = {
    x: left,
    y: top,
    top,
    bottom,
    left,
    right,
    width,
    height
  };
  return {
    ...props,
    toJSON: () => props
  };
};

const mergeClientRects = clientRects => {
  if (clientRects.length === 0) {
    throw new Error('clientRects should not be empty');
  }
  return makeClientRect({
    top: Math.min(...clientRects.map(rect => rect.top)),
    bottom: Math.max(...clientRects.map(rect => rect.bottom)),
    left: Math.min(...clientRects.map(rect => rect.left)),
    right: Math.max(...clientRects.map(rect => rect.right))
  });
};

const getBoundingClientRect = (editor, at) => {
  const atRanges = (() => {
    if (!at) return [editor.selection].filter(Boolean);
    const atArray = Array.isArray(at) && !slate.Path.isPath(at) ? at : [at];
    return atArray.map(location => plateCommon.getRange(editor, location));
  })();
  const clientRects = atRanges.map(range => {
    var _toDOMRange;
    return (_toDOMRange = plateCommon.toDOMRange(editor, range)) === null || _toDOMRange === void 0 ? void 0 : _toDOMRange.getBoundingClientRect();
  }).filter(Boolean);
  if (clientRects.length === 0) return undefined;
  return mergeClientRects(clientRects);
};

const createVirtualRef = (editor, at, {
  fallbackRect
} = {}) => ({
  current: {
    getBoundingClientRect: () => {
      const rect = getBoundingClientRect(editor, at) || fallbackRect;
      if (!rect) {
        throw new Error('Could not get the bounding client rect of the location. Please provide a fallbackRect.');
      }
      return rect;
    }
  }
});

/**
 * Get bounding client rect by slate range
 */
const getRangeBoundingClientRect = (editor, at) => {
  if (!at) return getDefaultBoundingClientRect();
  const domRange = plateCommon.toDOMRange(editor, at);
  if (!domRange) return getDefaultBoundingClientRect();
  return domRange.getBoundingClientRect();
};

/**
 * Get bounding client rect of the window selection
 */
const getSelectionBoundingClientRect = () => {
  const domSelection = window.getSelection();
  if (!domSelection || domSelection.rangeCount < 1) {
    return getDefaultBoundingClientRect();
  }
  const domRange = domSelection.getRangeAt(0);
  return domRange.getBoundingClientRect();
};

/**
 * `useFloating` with a controlled virtual element. Used to follow cursor position.
 *
 * Default options:
 * - `whileElementsMounted: autoUpdate`
 *
 * Additional options:
 * - `getBoundingClientRect` to get the bounding client rect.
 * - `hidden` to hide the floating element
 *
 * Additional returns:
 * - `style` to apply to the floating element
 * - `virtualElementRef`
 *
 * @see useFloating
 * @see https://floating-ui.com/docs/react-dom#virtual-element
 */
const useVirtualFloating = ({
  getBoundingClientRect = getSelectionBoundingClientRect,
  ...floatingOptions
}) => {
  const virtualElementRef = react$1.useRef(createVirtualElement());
  const [visible, setVisible] = react$1.useState(true);
  const floatingResult = react.useFloating({
    // update on scroll and resize
    whileElementsMounted: react.autoUpdate,
    ...floatingOptions
  });
  const {
    refs,
    middlewareData,
    strategy,
    x,
    y,
    update
  } = floatingResult;
  plateCommon.useIsomorphicLayoutEffect(() => {
    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect;
  }, [getBoundingClientRect, update]);
  plateCommon.useIsomorphicLayoutEffect(() => {
    refs.setReference(virtualElementRef.current);
  }, [refs]);
  plateCommon.useIsomorphicLayoutEffect(() => {
    if (!(middlewareData !== null && middlewareData !== void 0 && middlewareData.hide)) return;
    const {
      referenceHidden
    } = middlewareData.hide;
    setVisible(!referenceHidden);
  }, [middlewareData.hide]);
  return {
    ...floatingResult,
    virtualElementRef,
    style: {
      position: strategy,
      top: y !== null && y !== void 0 ? y : 0,
      left: x !== null && x !== void 0 ? x : 0,
      display: floatingOptions.open === false ? 'none' : undefined,
      visibility: visible ? undefined : 'hidden'
    }
  };
};

Object.defineProperty(exports, 'FloatingDelayGroup', {
  enumerable: true,
  get: function () { return react.FloatingDelayGroup; }
});
Object.defineProperty(exports, 'FloatingFocusManager', {
  enumerable: true,
  get: function () { return react.FloatingFocusManager; }
});
Object.defineProperty(exports, 'FloatingNode', {
  enumerable: true,
  get: function () { return react.FloatingNode; }
});
Object.defineProperty(exports, 'FloatingOverlay', {
  enumerable: true,
  get: function () { return react.FloatingOverlay; }
});
Object.defineProperty(exports, 'FloatingPortal', {
  enumerable: true,
  get: function () { return react.FloatingPortal; }
});
Object.defineProperty(exports, 'FloatingTree', {
  enumerable: true,
  get: function () { return react.FloatingTree; }
});
Object.defineProperty(exports, 'arrow', {
  enumerable: true,
  get: function () { return react.arrow; }
});
Object.defineProperty(exports, 'autoPlacement', {
  enumerable: true,
  get: function () { return react.autoPlacement; }
});
Object.defineProperty(exports, 'autoUpdate', {
  enumerable: true,
  get: function () { return react.autoUpdate; }
});
Object.defineProperty(exports, 'computePosition', {
  enumerable: true,
  get: function () { return react.computePosition; }
});
Object.defineProperty(exports, 'detectOverflow', {
  enumerable: true,
  get: function () { return react.detectOverflow; }
});
Object.defineProperty(exports, 'flip', {
  enumerable: true,
  get: function () { return react.flip; }
});
Object.defineProperty(exports, 'getOverflowAncestors', {
  enumerable: true,
  get: function () { return react.getOverflowAncestors; }
});
Object.defineProperty(exports, 'hide', {
  enumerable: true,
  get: function () { return react.hide; }
});
Object.defineProperty(exports, 'inline', {
  enumerable: true,
  get: function () { return react.inline; }
});
Object.defineProperty(exports, 'limitShift', {
  enumerable: true,
  get: function () { return react.limitShift; }
});
Object.defineProperty(exports, 'offset', {
  enumerable: true,
  get: function () { return react.offset; }
});
Object.defineProperty(exports, 'safePolygon', {
  enumerable: true,
  get: function () { return react.safePolygon; }
});
Object.defineProperty(exports, 'shift', {
  enumerable: true,
  get: function () { return react.shift; }
});
Object.defineProperty(exports, 'size', {
  enumerable: true,
  get: function () { return react.size; }
});
Object.defineProperty(exports, 'useClick', {
  enumerable: true,
  get: function () { return react.useClick; }
});
Object.defineProperty(exports, 'useDelayGroup', {
  enumerable: true,
  get: function () { return react.useDelayGroup; }
});
Object.defineProperty(exports, 'useDelayGroupContext', {
  enumerable: true,
  get: function () { return react.useDelayGroupContext; }
});
Object.defineProperty(exports, 'useDismiss', {
  enumerable: true,
  get: function () { return react.useDismiss; }
});
Object.defineProperty(exports, 'useFloating', {
  enumerable: true,
  get: function () { return react.useFloating; }
});
Object.defineProperty(exports, 'useFloatingNodeId', {
  enumerable: true,
  get: function () { return react.useFloatingNodeId; }
});
Object.defineProperty(exports, 'useFloatingParentNodeId', {
  enumerable: true,
  get: function () { return react.useFloatingParentNodeId; }
});
Object.defineProperty(exports, 'useFloatingPortalNode', {
  enumerable: true,
  get: function () { return react.useFloatingPortalNode; }
});
Object.defineProperty(exports, 'useFloatingTree', {
  enumerable: true,
  get: function () { return react.useFloatingTree; }
});
Object.defineProperty(exports, 'useFocus', {
  enumerable: true,
  get: function () { return react.useFocus; }
});
Object.defineProperty(exports, 'useHover', {
  enumerable: true,
  get: function () { return react.useHover; }
});
Object.defineProperty(exports, 'useId', {
  enumerable: true,
  get: function () { return react.useId; }
});
Object.defineProperty(exports, 'useInteractions', {
  enumerable: true,
  get: function () { return react.useInteractions; }
});
Object.defineProperty(exports, 'useListNavigation', {
  enumerable: true,
  get: function () { return react.useListNavigation; }
});
Object.defineProperty(exports, 'useRole', {
  enumerable: true,
  get: function () { return react.useRole; }
});
Object.defineProperty(exports, 'useTypeahead', {
  enumerable: true,
  get: function () { return react.useTypeahead; }
});
exports.DropdownMenu = reactDropdownMenu__namespace;
exports.createVirtualElement = createVirtualElement;
exports.createVirtualRef = createVirtualRef;
exports.getBoundingClientRect = getBoundingClientRect;
exports.getDefaultBoundingClientRect = getDefaultBoundingClientRect;
exports.getRangeBoundingClientRect = getRangeBoundingClientRect;
exports.getSelectionBoundingClientRect = getSelectionBoundingClientRect;
exports.makeClientRect = makeClientRect;
exports.mergeClientRects = mergeClientRects;
exports.useFloatingToolbar = useFloatingToolbar;
exports.useFloatingToolbarState = useFloatingToolbarState;
exports.useVirtualFloating = useVirtualFloating;
//# sourceMappingURL=index.js.map
