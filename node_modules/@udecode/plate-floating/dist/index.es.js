import { useState, useEffect, useRef } from 'react';
import { usePlateEditorState, useEventEditorSelectors, isSelectionExpanded, getSelectionText, mergeProps, getRange, toDOMRange, useIsomorphicLayoutEffect } from '@udecode/plate-common';
import { useFocused } from 'slate-react';
import { useFloating, autoUpdate } from '@floating-ui/react';
export { FloatingDelayGroup, FloatingFocusManager, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, safePolygon, shift, size, useClick, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInteractions, useListNavigation, useRole, useTypeahead } from '@floating-ui/react';
import { Path } from 'slate';
import * as reactDropdownMenu from '@radix-ui/react-dropdown-menu';
export { reactDropdownMenu as DropdownMenu };

const getDefaultBoundingClientRect = () => ({
  width: 0,
  height: 0,
  x: 0,
  y: 0,
  top: -9999,
  left: -9999,
  right: 9999,
  bottom: 9999
});
const createVirtualElement = () => ({
  getBoundingClientRect: getDefaultBoundingClientRect
});

const useFloatingToolbarState = ({
  floatingOptions,
  hideToolbar,
  ignoreReadOnly
}) => {
  const editor = usePlateEditorState();
  const focusedEditorId = useEventEditorSelectors.focus();
  const focused = useFocused();
  const [open, setOpen] = useState(false);
  const [waitForCollapsedSelection, setWaitForCollapsedSelection] = useState(false);
  const selectionExpanded = editor && isSelectionExpanded(editor);
  const selectionText = editor && getSelectionText(editor);
  const floating = useVirtualFloating(mergeProps({
    getBoundingClientRect: getSelectionBoundingClientRect,
    open,
    onOpenChange: setOpen
  }, floatingOptions));
  return {
    editor,
    open,
    setOpen,
    waitForCollapsedSelection,
    setWaitForCollapsedSelection,
    selectionExpanded,
    selectionText,
    focused,
    focusedEditorId,
    ignoreReadOnly,
    hideToolbar,
    floating
  };
};
const useFloatingToolbar = ({
  editor,
  selectionExpanded,
  selectionText,
  waitForCollapsedSelection,
  setWaitForCollapsedSelection,
  open,
  setOpen,
  focused,
  focusedEditorId,
  floating,
  ignoreReadOnly,
  hideToolbar
}) => {
  var _selectionText$length;
  // On refocus, the editor keeps the previous selection,
  // so we need to wait it's collapsed at the new position before displaying the floating toolbar.
  useEffect(() => {
    if (!focused || ignoreReadOnly) {
      setWaitForCollapsedSelection(true);
    }
    if (!selectionExpanded) {
      setWaitForCollapsedSelection(false);
    }
  }, [focused, ignoreReadOnly, selectionExpanded, setWaitForCollapsedSelection]);
  useEffect(() => {
    if (!selectionExpanded || !selectionText || !(editor.id === focusedEditorId || ignoreReadOnly) && hideToolbar) {
      setOpen(false);
    } else if (selectionText && selectionExpanded && !waitForCollapsedSelection) {
      setOpen(true);
    }
  }, [setOpen, editor.id, editor.selection, focusedEditorId, hideToolbar, ignoreReadOnly, selectionExpanded, selectionText, waitForCollapsedSelection]);
  const {
    update
  } = floating;
  const selectionTextLength = (_selectionText$length = selectionText === null || selectionText === void 0 ? void 0 : selectionText.length) !== null && _selectionText$length !== void 0 ? _selectionText$length : 0;
  useEffect(() => {
    if (selectionTextLength > 0) {
      update === null || update === void 0 ? void 0 : update();
    }
  }, [selectionTextLength, update]);
  return {
    ref: floating.refs.setFloating,
    props: {
      style: floating.style
    },
    hidden: !open
  };
};

const makeClientRect = ({
  top,
  bottom,
  left,
  right
}) => {
  const width = right - left;
  const height = bottom - top;
  const props = {
    x: left,
    y: top,
    top,
    bottom,
    left,
    right,
    width,
    height
  };
  return {
    ...props,
    toJSON: () => props
  };
};

const mergeClientRects = clientRects => {
  if (clientRects.length === 0) {
    throw new Error('clientRects should not be empty');
  }
  return makeClientRect({
    top: Math.min(...clientRects.map(rect => rect.top)),
    bottom: Math.max(...clientRects.map(rect => rect.bottom)),
    left: Math.min(...clientRects.map(rect => rect.left)),
    right: Math.max(...clientRects.map(rect => rect.right))
  });
};

const getBoundingClientRect = (editor, at) => {
  const atRanges = (() => {
    if (!at) return [editor.selection].filter(Boolean);
    const atArray = Array.isArray(at) && !Path.isPath(at) ? at : [at];
    return atArray.map(location => getRange(editor, location));
  })();
  const clientRects = atRanges.map(range => {
    var _toDOMRange;
    return (_toDOMRange = toDOMRange(editor, range)) === null || _toDOMRange === void 0 ? void 0 : _toDOMRange.getBoundingClientRect();
  }).filter(Boolean);
  if (clientRects.length === 0) return undefined;
  return mergeClientRects(clientRects);
};

const createVirtualRef = (editor, at, {
  fallbackRect
} = {}) => ({
  current: {
    getBoundingClientRect: () => {
      const rect = getBoundingClientRect(editor, at) || fallbackRect;
      if (!rect) {
        throw new Error('Could not get the bounding client rect of the location. Please provide a fallbackRect.');
      }
      return rect;
    }
  }
});

/**
 * Get bounding client rect by slate range
 */
const getRangeBoundingClientRect = (editor, at) => {
  if (!at) return getDefaultBoundingClientRect();
  const domRange = toDOMRange(editor, at);
  if (!domRange) return getDefaultBoundingClientRect();
  return domRange.getBoundingClientRect();
};

/**
 * Get bounding client rect of the window selection
 */
const getSelectionBoundingClientRect = () => {
  const domSelection = window.getSelection();
  if (!domSelection || domSelection.rangeCount < 1) {
    return getDefaultBoundingClientRect();
  }
  const domRange = domSelection.getRangeAt(0);
  return domRange.getBoundingClientRect();
};

/**
 * `useFloating` with a controlled virtual element. Used to follow cursor position.
 *
 * Default options:
 * - `whileElementsMounted: autoUpdate`
 *
 * Additional options:
 * - `getBoundingClientRect` to get the bounding client rect.
 * - `hidden` to hide the floating element
 *
 * Additional returns:
 * - `style` to apply to the floating element
 * - `virtualElementRef`
 *
 * @see useFloating
 * @see https://floating-ui.com/docs/react-dom#virtual-element
 */
const useVirtualFloating = ({
  getBoundingClientRect = getSelectionBoundingClientRect,
  ...floatingOptions
}) => {
  const virtualElementRef = useRef(createVirtualElement());
  const [visible, setVisible] = useState(true);
  const floatingResult = useFloating({
    // update on scroll and resize
    whileElementsMounted: autoUpdate,
    ...floatingOptions
  });
  const {
    refs,
    middlewareData,
    strategy,
    x,
    y,
    update
  } = floatingResult;
  useIsomorphicLayoutEffect(() => {
    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect;
  }, [getBoundingClientRect, update]);
  useIsomorphicLayoutEffect(() => {
    refs.setReference(virtualElementRef.current);
  }, [refs]);
  useIsomorphicLayoutEffect(() => {
    if (!(middlewareData !== null && middlewareData !== void 0 && middlewareData.hide)) return;
    const {
      referenceHidden
    } = middlewareData.hide;
    setVisible(!referenceHidden);
  }, [middlewareData.hide]);
  return {
    ...floatingResult,
    virtualElementRef,
    style: {
      position: strategy,
      top: y !== null && y !== void 0 ? y : 0,
      left: x !== null && x !== void 0 ? x : 0,
      display: floatingOptions.open === false ? 'none' : undefined,
      visibility: visible ? undefined : 'hidden'
    }
  };
};

export { createVirtualElement, createVirtualRef, getBoundingClientRect, getDefaultBoundingClientRect, getRangeBoundingClientRect, getSelectionBoundingClientRect, makeClientRect, mergeClientRects, useFloatingToolbar, useFloatingToolbarState, useVirtualFloating };
//# sourceMappingURL=index.es.js.map
