import { findNode, getEdgePoints, getPointAfter, getPointBefore, createAtomStore, JotaiProvider, getJotaiProviderInitialValues, nanoid, usePlateEditorRef, usePlateSelectors, isDefined, getNodeEntries, getPluginOptions, isInline, withoutNormalizing, addRangeMarks, setNodes, createPointRef, isRangeAcrossBlocks, getEditorString, unhangCharacterRange, isBlock, isStartPoint, isElementEmpty, removeNodes, moveSelection, deleteText, collapseSelection, applyDeepToNodes, isSelectionExpanded, insertNodes, getNode, unsetNodes, createPluginFactory } from '@udecode/plate-common';
import React, { useEffect } from 'react';
import { Point } from 'slate';

const MARK_SUGGESTION = 'suggestion';
const KEY_SUGGESTION_ID = 'suggestionId';

const findSuggestionNode = (editor, {
  match,
  ...options
} = {}) => findNode(editor, {
  match: (n, p) => n[MARK_SUGGESTION] && (!match || match(n, p)),
  ...options
});

/**
 * Find the suggestion id at the cursor point, the point before and after (if offset = 0).
 */
const findSuggestionId = (editor, at) => {
  let entry = findSuggestionNode(editor, {
    at
  });
  if (!entry) {
    let start;
    let end;
    try {
      [start, end] = getEdgePoints(editor, at);
    } catch {
      return;
    }
    const nextPoint = getPointAfter(editor, end);
    if (nextPoint) {
      entry = findSuggestionNode(editor, {
        at: nextPoint
      });
      if (!entry) {
        const prevPoint = getPointBefore(editor, start);
        if (prevPoint) {
          entry = findSuggestionNode(editor, {
            at: prevPoint
          });
        }
      }
    }
  }
  if (entry) {
    return entry[0][KEY_SUGGESTION_ID];
  }
};

const SCOPE_SUGGESTION = Symbol('suggestion');
const {
  suggestionStore,
  useSuggestionStore
} = createAtomStore({
  /**
   * Id of the current user.
   */
  currentUserId: null,
  /**
   * Users data.
   */
  users: {},
  /**
   * Suggestion data.
   */
  suggestions: {},
  isSuggesting: false,
  /**
   * Id of the active suggestion. If null, no suggestion is active.
   */
  activeSuggestionId: null,
  onSuggestionAdd: null,
  onSuggestionUpdate: null,
  onSuggestionDelete: null
}, {
  name: 'suggestion',
  scope: SCOPE_SUGGESTION
});
function SuggestionProvider({
  children,
  ...props
}) {
  return /*#__PURE__*/React.createElement(JotaiProvider, {
    initialValues: getJotaiProviderInitialValues(suggestionStore, props),
    scope: SCOPE_SUGGESTION
  }, children);
}
const useSuggestionStates = () => useSuggestionStore().use;
const useSuggestionSelectors = () => useSuggestionStore().get;
const useSuggestionActions = () => useSuggestionStore().set;
const useSuggestionById = id => {
  const suggestion = useSuggestionSelectors().suggestions();
  if (!id) return null;
  return suggestion[id];
};
const useSuggestionUserById = id => {
  const users = useSuggestionSelectors().users();
  if (!id) return null;
  return users[id];
};
const useCurrentSuggestionUser = () => {
  const users = useSuggestionSelectors().users();
  const currentUserId = useSuggestionSelectors().currentUserId();
  if (!currentUserId) return null;
  return users[currentUserId];
};
const useUpdateSuggestion = id => {
  const suggestion = useSuggestionById(id);
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  return value => {
    if (!id) return;
    setSuggestions({
      ...suggestions,
      [id]: {
        ...suggestion,
        ...value
      }
    });
  };
};
const useAddSuggestion = () => {
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  const currentUserId = useSuggestionSelectors().currentUserId();
  return value => {
    var _value$id;
    if (!currentUserId) return;
    const id = (_value$id = value.id) !== null && _value$id !== void 0 ? _value$id : nanoid();
    setSuggestions({
      ...suggestions,
      [id]: {
        id,
        userId: currentUserId,
        createdAt: Date.now(),
        ...value
      }
    });
  };
};
const useRemoveSuggestion = () => {
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  return id => {
    if (!id) return;
    delete suggestions[id];
    setSuggestions({
      ...suggestions
    });
  };
};

const useSetActiveSuggestionId = () => {
  const editor = usePlateEditorRef();
  const setActiveSuggestionId = useSuggestionActions().activeSuggestionId();
  return value => {
    setActiveSuggestionId(value);
    editor.activeSuggestionId = value;
  };
};

const getSuggestionId = node => {
  return node[KEY_SUGGESTION_ID];
};

const useHooksSuggestion = (editor, plugin) => {
  const key = usePlateSelectors().keyEditor();
  const setActiveSuggestionId = useSetActiveSuggestionId();

  /**
   * Set the active suggestion to the selected suggestion (or the first such
   * suggestion if there are multiple). If there is no selected suggestion,
   * set the active suggestion to null.
   */
  useEffect(() => {
    if (!editor.selection) return;
    const resetActiveSuggestion = () => {
      setActiveSuggestionId(null);
    };
    const suggestionEntry = findSuggestionNode(editor);
    if (!suggestionEntry) return resetActiveSuggestion();
    const [suggestionNode] = suggestionEntry;
    const id = getSuggestionId(suggestionNode);
    if (!id) return resetActiveSuggestion();
    setActiveSuggestionId(id);
  }, [editor, key, setActiveSuggestionId]);
};

const getSuggestionKey = (id = '0') => `${MARK_SUGGESTION}_${id}`;
const isSuggestionKey = key => key.startsWith(`${MARK_SUGGESTION}_`);
const getSuggestionKeys = node => {
  const keys = [];
  Object.keys(node).forEach(key => {
    if (isSuggestionKey(key)) keys.push(key);
  });
  return keys;
};
const getSuggestionUserIdByKey = key => isDefined(key) ? key.split(`${MARK_SUGGESTION}_`)[1] : null;
const getSuggestionUserIds = node => {
  return getSuggestionKeys(node).map(key => getSuggestionUserIdByKey(key));
};
const getSuggestionUserId = node => {
  return getSuggestionUserIds(node)[0];
};

const getSuggestionNodeEntries = (editor, suggestionId, {
  at = [],
  match = () => true,
  ...options
} = {}) => getNodeEntries(editor, {
  at,
  match: n => n.suggestionId === suggestionId && match(n),
  ...options
});

// TODO: Move to ../types

/**
 * Get the suggestion descriptions of the selected node.
 * A node can have multiple suggestions (multiple users).
 * Each description maps to a user suggestion.
 */
const getActiveSuggestionDescriptions = editor => {
  const aboveEntry = findSuggestionNode(editor);
  if (!aboveEntry) return [];
  const aboveNode = aboveEntry[0];
  const suggestionId = aboveNode.suggestionId;
  const userIds = getSuggestionUserIds(aboveNode);
  return userIds.map(userId => {
    const nodes = Array.from(getSuggestionNodeEntries(editor, suggestionId, {
      match: n => n[getSuggestionKey(userId)]
    })).map(([node]) => node);
    const insertions = nodes.filter(node => !node.suggestionDeletion);
    const deletions = nodes.filter(node => node.suggestionDeletion);
    const insertedText = insertions.map(node => node.text).join('');
    const deletedText = deletions.map(node => node.text).join('');
    if (insertions.length > 0 && deletions.length > 0) {
      return {
        type: 'replacement',
        userId,
        suggestionId,
        insertedText,
        deletedText
      };
    }
    if (deletions.length > 0) {
      return {
        type: 'deletion',
        userId,
        suggestionId,
        deletedText
      };
    }
    return {
      type: 'insertion',
      userId,
      suggestionId,
      insertedText
    };
  });
};

const getSuggestionCurrentUserKey = editor => {
  const {
    currentUserId
  } = getPluginOptions(editor, MARK_SUGGESTION);
  return getSuggestionKey(currentUserId);
};
const getSuggestionProps = (editor, id, {
  suggestionDeletion
} = {}) => {
  const res = {
    [MARK_SUGGESTION]: true,
    [KEY_SUGGESTION_ID]: id,
    [getSuggestionCurrentUserKey(editor)]: true
  };
  if (suggestionDeletion) {
    res.suggestionDeletion = true;
  }
  return res;
};

const setSuggestionNodes = (editor, options) => {
  const {
    at = editor.selection,
    suggestionId = nanoid()
  } = options !== null && options !== void 0 ? options : {};

  // TODO: get all inline nodes to be set
  const _nodeEntries = getNodeEntries(editor, {
    match: n => isInline(editor, n),
    ...options
  });
  const nodeEntries = [..._nodeEntries];
  withoutNormalizing(editor, () => {
    const props = getSuggestionProps(editor, suggestionId, options);
    addRangeMarks(editor, props, {
      at
    });
    nodeEntries.forEach(([, path]) => {
      setNodes(editor, props, {
        at: path,
        match: n => {
          if (!isInline(editor, n)) return false;
          return true;
        },
        ...options
      });
    });
  });
};

/**
 * Suggest deletion one character at a time until target point is reached.
 * Suggest additions are safely deleted.
 */
const deleteSuggestion = (editor, at, {
  reverse
} = {}) => {
  withoutNormalizing(editor, () => {
    var _findSuggestionId;
    const {
      anchor: from,
      focus: to
    } = at;
    const suggestionId = (_findSuggestionId = findSuggestionId(editor, from)) !== null && _findSuggestionId !== void 0 ? _findSuggestionId : nanoid();
    const toRef = createPointRef(editor, to);
    let pointCurrent;
    while (true) {
      var _editor$selection;
      pointCurrent = (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor;
      if (!pointCurrent) break;
      const pointTarget = toRef.current;
      if (!pointTarget) break;

      // don't delete across blocks
      if (!isRangeAcrossBlocks(editor, {
        at: {
          anchor: pointCurrent,
          focus: pointTarget
        }
      })) {
        // always 0 when across blocks
        const str = getEditorString(editor, reverse ? {
          anchor: pointTarget,
          focus: pointCurrent
        } : {
          anchor: pointCurrent,
          focus: pointTarget
        });
        if (str.length === 0) break;
      }
      const getPoint = reverse ? getPointBefore : getPointAfter;
      const pointNext = getPoint(editor, pointCurrent, {
        unit: 'character'
      });
      if (!pointNext) break;
      let range = reverse ? {
        anchor: pointNext,
        focus: pointCurrent
      } : {
        anchor: pointCurrent,
        focus: pointNext
      };
      range = unhangCharacterRange(editor, range);

      // if the current point is in block addition suggestion, delete block
      const entryBlock = findNode(editor, {
        at: pointCurrent,
        match: n => isBlock(editor, n) && n[MARK_SUGGESTION] && !n.suggestionDeletion && n[getSuggestionCurrentUserKey(editor)]
      });
      if (entryBlock && isStartPoint(editor, pointCurrent, entryBlock[1]) && isElementEmpty(editor, entryBlock[0])) {
        removeNodes(editor, {
          at: entryBlock[1]
        });
        continue;
      }

      // move selection if still the same
      if (Point.equals(pointCurrent, editor.selection.anchor)) {
        moveSelection(editor, {
          reverse,
          unit: 'character'
        });
      }

      // skip if the range is across blocks
      if (isRangeAcrossBlocks(editor, {
        at: range
      })) {
        continue;
      }

      // if the current point is in addition suggestion, delete
      const entryText = findSuggestionNode(editor, {
        at: range,
        match: n => !n.suggestionDeletion && n[getSuggestionCurrentUserKey(editor)]
      });
      if (entryText) {
        deleteText(editor, {
          at: range,
          unit: 'character'
        });
        continue;
      }
      setSuggestionNodes(editor, {
        at: range,
        suggestionDeletion: true,
        suggestionId
      });
    }
  });
};

const deleteFragmentSuggestion = (editor, {
  reverse
} = {}) => {
  withoutNormalizing(editor, () => {
    const selection = editor.selection;
    const [start, end] = getEdgePoints(editor, selection);
    if (reverse) {
      collapseSelection(editor, {
        edge: 'end'
      });
      deleteSuggestion(editor, {
        anchor: end,
        focus: start
      }, {
        reverse: true
      });
    } else {
      collapseSelection(editor, {
        edge: 'start'
      });
      deleteSuggestion(editor, {
        anchor: start,
        focus: end
      });
    }
  });
};

const insertFragmentSuggestion = (editor, fragment, {
  insertFragment = editor.insertFragment
} = {}) => {
  withoutNormalizing(editor, () => {
    var _findSuggestionId;
    deleteFragmentSuggestion(editor);
    const id = (_findSuggestionId = findSuggestionId(editor, editor.selection)) !== null && _findSuggestionId !== void 0 ? _findSuggestionId : nanoid();
    fragment.forEach(node => {
      applyDeepToNodes({
        node,
        source: {},
        apply: n => {
          if (!n[MARK_SUGGESTION]) {
            // Add suggestion mark
            n[MARK_SUGGESTION] = true;
          }
          if (n.suggestionDeletion) {
            // Remove suggestion deletion mark
            delete n.suggestionDeletion;
          }
          n[KEY_SUGGESTION_ID] = id;

          // remove the other user keys
          const otherUserKeys = getSuggestionKeys(n);
          otherUserKeys.forEach(key => {
            delete n[key];
          });

          // set current user key
          n[getSuggestionCurrentUserKey(editor)] = true;
        }
      });
    });
    insertFragment(fragment);
  });
};

const insertTextSuggestion = (editor, text) => {
  withoutNormalizing(editor, () => {
    var _findSuggestionId;
    const id = (_findSuggestionId = findSuggestionId(editor, editor.selection)) !== null && _findSuggestionId !== void 0 ? _findSuggestionId : nanoid();
    if (isSelectionExpanded(editor)) {
      deleteFragmentSuggestion(editor);
    }
    insertNodes(editor, {
      text,
      ...getSuggestionProps(editor, id)
    }, {
      at: editor.selection,
      select: true
    });
  });
};

const withSuggestion = (e, plugin) => {
  const editor = e;
  const {
    normalizeNode,
    insertText,
    insertFragment,
    insertBreak,
    deleteBackward,
    deleteForward,
    deleteFragment
  } = editor;
  editor.isSuggesting = false;
  editor.insertBreak = () => {
    if (editor.isSuggesting) {
      // TODO: split node
      insertTextSuggestion(editor, '\n');
      return;
    }
    insertBreak();
  };
  editor.insertText = text => {
    if (editor.isSuggesting) {
      insertTextSuggestion(editor, text);
      return;
    }
    insertText(text);
  };
  editor.insertFragment = fragment => {
    if (editor.isSuggesting) {
      insertFragmentSuggestion(editor, fragment, {
        insertFragment
      });
      return;
    }
    insertFragment(fragment);
  };
  editor.deleteFragment = direction => {
    if (editor.isSuggesting) {
      deleteFragmentSuggestion(editor, {
        reverse: true
      });
      return;
    }
    deleteFragment(direction);
  };
  editor.deleteBackward = unit => {
    if (editor.isSuggesting) {
      const selection = editor.selection;
      const pointTarget = getPointBefore(editor, selection, {
        unit
      });
      if (!pointTarget) return;
      deleteSuggestion(editor, {
        anchor: selection.anchor,
        focus: pointTarget
      }, {
        reverse: true
      });
      return;
    }
    deleteBackward(unit);
  };
  editor.deleteForward = unit => {
    if (editor.isSuggesting) {
      const selection = editor.selection;
      const pointTarget = getPointAfter(editor, selection, {
        unit
      });
      if (!pointTarget) return;
      deleteSuggestion(editor, {
        anchor: selection.anchor,
        focus: pointTarget
      });
      return;
    }
    deleteForward(unit);
  };
  editor.normalizeNode = entry => {
    const [node, path] = entry;
    if (node[MARK_SUGGESTION]) {
      const pointBefore = getPointBefore(editor, path);
      // Merge with previous suggestion
      if (pointBefore) {
        const nodeBefore = getNode(editor, pointBefore.path);
        if (nodeBefore !== null && nodeBefore !== void 0 && nodeBefore[MARK_SUGGESTION] && nodeBefore[KEY_SUGGESTION_ID] !== node[KEY_SUGGESTION_ID]) {
          setNodes(editor, {
            [KEY_SUGGESTION_ID]: nodeBefore[KEY_SUGGESTION_ID]
          }, {
            at: path
          });
          return;
        }
      }

      // Unset suggestion when there is no suggestion id
      if (!getSuggestionId(node)) {
        const keys = getSuggestionKeys(node);
        unsetNodes(editor, [MARK_SUGGESTION, 'suggestionDeletion', ...keys], {
          at: path
        });
        return;
      }

      // Unset suggestion when there is no suggestion user id
      if (getSuggestionKeys(node).length === 0) {
        if (node.suggestionDeletion) {
          // Unset deletions
          unsetNodes(editor, [MARK_SUGGESTION, KEY_SUGGESTION_ID], {
            at: path
          });
        } else {
          // Remove additions
          removeNodes(editor, {
            at: path
          });
        }
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
};

// editor.apply = (op) => {
//   if (editor.isSuggesting) {
//     if (op.type === 'insert_text') {
//       const { text, path, offset } = op;
//
//       const id = findSuggestionId(editor, { path, offset }) ?? nanoid();
//
//       // const node = getNode(editor, path) as TSuggestionText;
//       // if (node && node.suggestionId !== id) {
//       insertNodes<TSuggestionText>(
//         editor,
//         { text, [MARK_SUGGESTION]: true, [KEY_SUGGESTION_ID]: id },
//         {
//           at: {
//             path,
//             offset,
//           },
//           select: true,
//         }
//       );
//       return;
//       // }
//     }
//     if (op.type === 'insert_node') {
//       const { node, path } = op;
//
//       const suggestionNode = node as TSuggestionText;
//
//       if (
//         suggestionNode[MARK_SUGGESTION] &&
//         suggestionNode[KEY_SUGGESTION_ID] &&
//         !suggestionNode.suggestionDeletion
//       ) {
//         apply(op);
//         return;
//       }
//
//       if (!suggestionNode[MARK_SUGGESTION]) {
//         // Add suggestion mark
//         suggestionNode[MARK_SUGGESTION] = true;
//       }
//       if (suggestionNode.suggestionDeletion) {
//         // Remove suggestion deletion mark
//         delete suggestionNode.suggestionDeletion;
//       }
//
//       const id = findSuggestionId(editor, path) ?? nanoid();
//       suggestionNode[KEY_SUGGESTION_ID] = id;
//
//       insertNodes(editor, cloneDeep(node) as any, { at: path });
//       return;
//     }
//     if (op.type === 'remove_node') {
//       const { node } = op;
//
//       // additions are safe to remove
//       if (node[MARK_SUGGESTION]) {
//         if (!node.suggestionDeletion) {
//           apply(op);
//         }
//         return;
//       }
//
//       const path = findNodePath(editor, node);
//       if (!path) return;
//
//       const id = findSuggestionId(editor, path) ?? nanoid();
//
//       setSuggestionNodes(editor, {
//         at: path,
//         suggestionDeletion: true,
//         suggestionId: id,
//       });
//       // ðŸ’¡ set instead of remove -> selection gets wrong
//       return;
//     }
//     if (op.type === 'remove_text') {
//       const { path, offset, text } = op;
//
//       const from = { path, offset };
//
//       const node = getNode<TText>(editor, path);
//       if (!node) return;
//
//       // additions are safe to remove
//       if (node[MARK_SUGGESTION] && !node.suggestionDeletion) {
//         apply(op);
//         return;
//       }
//
//       const to = {
//         path,
//         offset: offset + text.length,
//       };
//       const id =
//         findSuggestionId(editor, {
//           anchor: from,
//           focus: to,
//         }) ?? nanoid();
//
//       setSuggestionNodes(editor, {
//         at: {
//           anchor: from,
//           focus: to,
//         },
//         suggestionDeletion: true,
//         suggestionId: id,
//       });
//       // ðŸ’¡ set instead of remove -> selection gets wrong
//       return;
//     }
//     if (op.type === 'move_node') {
//       const node = getNode(editor, op.path);
//       if (node && isBlock(editor, node) && !node[MARK_SUGGESTION]) {
//         // TODO: ?
//         return;
//       }
//     }
//     if (op.type === 'merge_node') {
//       const node = getNode(editor, op.path);
//       if (node && isBlock(editor, node)) {
//         // if (node && isBlock(editor, node) && !node[MARK_SUGGESTION]) {
//         // TODO: delete block suggestion
//         return;
//       }
//     }
//     if (op.type === 'split_node') {
//       const node = getNode(editor, op.path);
//       // allow splitting suggestion blocks
//       if (node && isBlock(editor, node) && !node[MARK_SUGGESTION]) {
//         // TODO: insert block suggestion
//         return;
//       }
//     }
//     if (op.type === 'set_selection') {
//       if (editor.preventSelection) {
//         return;
//       }
//     }
//   }
//
//   apply(op);
// };

const createSuggestionPlugin = createPluginFactory({
  key: MARK_SUGGESTION,
  isLeaf: true,
  useHooks: useHooksSuggestion,
  withOverrides: withSuggestion
});

const useSetIsSuggesting = () => {
  const editor = usePlateEditorRef();
  const setIsSuggesting = useSuggestionActions().isSuggesting();
  return value => {
    setIsSuggesting(value);
    editor.isSuggesting = value;
  };
};

const acceptSuggestion = (editor, description) => {
  withoutNormalizing(editor, () => {
    const suggestionKey = getSuggestionKey(description.userId);
    unsetNodes(editor, [MARK_SUGGESTION, suggestionKey], {
      at: [],
      match: n => {
        const node = n;

        // unset additions
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !node.suggestionDeletion && !!node[suggestionKey];
      }
    });
    removeNodes(editor, {
      at: [],
      match: n => {
        const node = n;

        // remove deletions
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !!node.suggestionDeletion && !!node[suggestionKey];
      }
    });
  });
};

const addSuggestionMark = editor => {
  var _findSuggestionId, _editor$marks, _editor$marks2;
  if (!editor.selection) return;
  const id = (_findSuggestionId = findSuggestionId(editor, editor.selection)) !== null && _findSuggestionId !== void 0 ? _findSuggestionId : nanoid();
  if (!((_editor$marks = editor.marks) !== null && _editor$marks !== void 0 && _editor$marks[MARK_SUGGESTION])) {
    editor.addMark(MARK_SUGGESTION, true);
  }
  if (!((_editor$marks2 = editor.marks) !== null && _editor$marks2 !== void 0 && _editor$marks2[KEY_SUGGESTION_ID])) {
    editor.addMark(KEY_SUGGESTION_ID, id);
  }
};

const rejectSuggestion = (editor, description) => {
  const suggestionKey = getSuggestionKey(description.userId);
  withoutNormalizing(editor, () => {
    unsetNodes(editor, [suggestionKey], {
      at: [],
      match: n => {
        const node = n;

        // unset deletions
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !!node.suggestionDeletion && !!node[suggestionKey];
      }
    });
    removeNodes(editor, {
      at: [],
      match: n => {
        const node = n;

        // remove additions
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !node.suggestionDeletion && !!node[suggestionKey];
      }
    });
  });
};

export { KEY_SUGGESTION_ID, MARK_SUGGESTION, SCOPE_SUGGESTION, SuggestionProvider, acceptSuggestion, addSuggestionMark, createSuggestionPlugin, deleteFragmentSuggestion, deleteSuggestion, findSuggestionId, findSuggestionNode, getActiveSuggestionDescriptions, getSuggestionCurrentUserKey, getSuggestionId, getSuggestionKey, getSuggestionKeys, getSuggestionNodeEntries, getSuggestionProps, getSuggestionUserId, getSuggestionUserIdByKey, getSuggestionUserIds, insertFragmentSuggestion, insertTextSuggestion, isSuggestionKey, rejectSuggestion, setSuggestionNodes, suggestionStore, useAddSuggestion, useCurrentSuggestionUser, useHooksSuggestion, useRemoveSuggestion, useSetActiveSuggestionId, useSetIsSuggesting, useSuggestionActions, useSuggestionById, useSuggestionSelectors, useSuggestionStates, useSuggestionStore, useSuggestionUserById, useUpdateSuggestion, withSuggestion };
//# sourceMappingURL=index.es.js.map
