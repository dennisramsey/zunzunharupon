import React, { useEffect, useState, useCallback, useRef } from 'react';
import { atom, createPrimitiveComponent, useAtom, JotaiProvider, createAtomStore, SCOPE_ELEMENT, useElement, usePlateEditorRef, findNodePath, select, setNodes } from '@udecode/plate-common';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

const isTouchEvent = event => 'touches' in event;

const resizeLengthToRelative = (length, parentLength) => {
  if (typeof length === 'number') {
    return `${length / parentLength * 100}%`;
  }
  return length;
};

const resizeLengthToStatic = (length, parentLength) => {
  if (typeof length === 'string') {
    return parentLength * Number.parseFloat(length) / 100;
  }
  return length;
};

const resizeLengthClampStatic = (length, {
  min,
  max
}) => {
  if (min !== undefined) {
    length = Math.max(length, min);
  }
  if (max !== undefined) {
    length = Math.min(length, max);
  }
  return length;
};
const resizeLengthClamp = (length, parentLength, {
  min,
  max
}) => {
  const staticLength = resizeLengthToStatic(length, parentLength);
  const clampedStaticLength = resizeLengthClampStatic(staticLength, {
    min: min === undefined ? undefined : resizeLengthToStatic(min, parentLength),
    max: max === undefined ? undefined : resizeLengthToStatic(max, parentLength)
  });
  switch (typeof length) {
    case 'string':
      {
        return resizeLengthToRelative(clampedStaticLength, parentLength);
      }
    case 'number':
      {
        return clampedStaticLength;
      }
    default:
      {
        throw new Error('Invalid length type');
      }
  }
};

const resizeHandleAtoms = {
  onResize: atom(null)
};
const ResizeHandleEffects = ({
  onResize
}) => {
  const [, setHandleResize] = useAtom(resizeHandleAtoms.onResize);
  useEffect(() => {
    setHandleResize({
      fn: onResize
    });
  }, [onResize, setHandleResize]);
  return null;
};
const ResizeHandleProvider = ({
  children,
  onResize
}) => {
  return /*#__PURE__*/React.createElement(JotaiProvider, {
    initialValues: [[resizeHandleAtoms.onResize, {
      fn: onResize
    }]]
  }, /*#__PURE__*/React.createElement(ResizeHandleEffects, {
    onResize: onResize
  }), children);
};
const useResizeHandleState = ({
  direction = 'left',
  onResize,
  onMouseDown,
  onTouchStart,
  onHover,
  onHoverEnd
}) => {
  const [_onResize] = useAtom(resizeHandleAtoms.onResize);
  if (!onResize) onResize = _onResize === null || _onResize === void 0 ? void 0 : _onResize.fn;
  const [isResizing, setIsResizing] = useState(false);
  const [initialPosition, setInitialPosition] = useState(0);
  const [initialSize, setInitialSize] = useState(0);
  const isHorizontal = direction === 'left' || direction === 'right';
  useEffect(() => {
    if (!isResizing) return;
    const sendResizeEvent = (event, finished) => {
      var _onResize2;
      const {
        clientX,
        clientY
      } = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
      const currentPosition = isHorizontal ? clientX : clientY;
      const delta = currentPosition - initialPosition;
      (_onResize2 = onResize) === null || _onResize2 === void 0 ? void 0 : _onResize2({
        initialSize,
        delta,
        finished,
        direction
      });
    };
    const handleMouseMove = event => sendResizeEvent(event, false);
    const handleMouseUp = event => {
      setIsResizing(false);
      onHoverEnd === null || onHoverEnd === void 0 ? void 0 : onHoverEnd();
      sendResizeEvent(event, true);
    };
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('touchmove', handleMouseMove);
    window.addEventListener('touchend', handleMouseUp);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('touchmove', handleMouseMove);
      window.removeEventListener('touchend', handleMouseUp);
    };
  }, [isResizing, initialPosition, initialSize, onResize, isHorizontal, onHoverEnd, direction]);
  return {
    isResizing,
    setIsResizing,
    initialPosition,
    setInitialPosition,
    initialSize,
    setInitialSize,
    isHorizontal,
    direction,
    onResize,
    onMouseDown,
    onTouchStart,
    onHover,
    onHoverEnd
  };
};
const useResizeHandle = ({
  setInitialPosition,
  setInitialSize,
  setIsResizing,
  onMouseDown,
  onTouchStart,
  isHorizontal,
  isResizing,
  onHover,
  onHoverEnd
}) => {
  const handleMouseDown = event => {
    const {
      clientX,
      clientY
    } = event;
    setInitialPosition(isHorizontal ? clientX : clientY);
    const element = event.target.parentElement;
    setInitialSize(isHorizontal ? element.offsetWidth : element.offsetHeight);
    setIsResizing(true);
    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(event);
  };
  const handleTouchStart = event => {
    const {
      touches
    } = event;
    const touch = touches[0];
    const {
      clientX,
      clientY
    } = touch;
    setInitialPosition(isHorizontal ? clientX : clientY);
    const element = event.target.parentElement;
    setInitialSize(isHorizontal ? element.offsetWidth : element.offsetHeight);
    setIsResizing(true);
    onTouchStart === null || onTouchStart === void 0 ? void 0 : onTouchStart(event);
  };
  const handleMouseOver = () => {
    onHover === null || onHover === void 0 ? void 0 : onHover();
  };
  const handleMouseOut = () => {
    if (!isResizing) {
      onHoverEnd === null || onHoverEnd === void 0 ? void 0 : onHoverEnd();
    }
  };
  return {
    props: {
      onMouseDown: handleMouseDown,
      onTouchStart: handleTouchStart,
      onMouseOver: handleMouseOver,
      onMouseOut: handleMouseOut,
      onTouchMove: handleMouseOver,
      onTouchEnd: handleMouseOut
    }
  };
};
const ResizeHandle = createPrimitiveComponent('div')({
  propsHook: useResizeHandle,
  stateHook: useResizeHandleState
});

const {
  resizableStore,
  useResizableStore
} = createAtomStore({
  width: 0
}, {
  name: 'resizable',
  scope: SCOPE_ELEMENT
});

const useResizableState = ({
  align = 'center',
  minWidth = 92,
  maxWidth = '100%'
} = {}) => {
  var _element$width;
  const element = useElement();
  const editor = usePlateEditorRef();
  const nodeWidth = (_element$width = element === null || element === void 0 ? void 0 : element.width) !== null && _element$width !== void 0 ? _element$width : '100%';
  const [width, setWidth] = useResizableStore().use.width();
  const setNodeWidth = useCallback(w => {
    const path = findNodePath(editor, element);
    if (!path) return;
    if (w === nodeWidth) {
      // Focus the node if not resized
      select(editor, path);
    } else {
      setNodes(editor, {
        width: w
      }, {
        at: path
      });
    }
  }, [editor, element, nodeWidth]);
  useEffect(() => {
    setWidth(nodeWidth);
  }, [nodeWidth, setWidth]);
  return {
    align,
    minWidth,
    maxWidth,
    setNodeWidth,
    setWidth,
    width
  };
};
const useResizable = ({
  align,
  minWidth,
  maxWidth,
  setNodeWidth,
  setWidth,
  width
}) => {
  const wrapperRef = useRef(null);
  return {
    wrapperRef,
    wrapperProps: {
      style: {
        position: 'relative'
      }
    },
    props: {
      style: {
        width,
        minWidth,
        maxWidth,
        position: 'relative'
      }
    },
    context: {
      onResize: useCallback(({
        initialSize,
        delta,
        finished,
        direction
      }) => {
        const wrapperStaticWidth = wrapperRef.current.offsetWidth;
        const deltaFactor = (align === 'center' ? 2 : 1) * (direction === 'left' ? -1 : 1);
        const newWidth = resizeLengthClamp(initialSize + delta * deltaFactor, wrapperStaticWidth, {
          min: minWidth,
          max: maxWidth
        });
        if (finished) {
          setNodeWidth(newWidth);
        } else {
          setWidth(newWidth);
        }
      }, [align, maxWidth, minWidth, setNodeWidth, setWidth])
    }
  };
};
const Resizable = /*#__PURE__*/React.forwardRef(({
  children,
  options,
  ...rest
}, ref) => {
  const state = useResizableState(options);
  const {
    wrapperRef,
    wrapperProps,
    props,
    context
  } = useResizable(state);
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: wrapperRef
  }, wrapperProps), /*#__PURE__*/React.createElement("div", _extends({
    ref: ref
  }, props, rest), /*#__PURE__*/React.createElement(ResizeHandleProvider, {
    onResize: context.onResize
  }, children)));
});
Resizable.displayName = 'Resizable';

export { Resizable, ResizeHandle, ResizeHandleEffects, ResizeHandleProvider, isTouchEvent, resizableStore, resizeHandleAtoms, resizeLengthClamp, resizeLengthClampStatic, resizeLengthToRelative, resizeLengthToStatic, useResizable, useResizableState, useResizableStore, useResizeHandle, useResizeHandleState };
//# sourceMappingURL=index.es.js.map
