{"version":3,"file":"index.es.js","sources":["../src/createTEditor.ts","../src/interfaces/editor/TEditor.ts","../src/interfaces/editor/addMark.ts","../src/interfaces/editor/createPathRef.ts","../src/interfaces/editor/createPointRef.ts","../src/interfaces/editor/createRangeRef.ts","../src/interfaces/editor/deleteBackward.ts","../src/interfaces/editor/deleteForward.ts","../src/interfaces/editor/deleteFragment.ts","../../../node_modules/lodash/isArray.js","../../../node_modules/lodash/castArray.js","../src/interfaces/element/elementMatches.ts","../src/interfaces/element/isElement.ts","../src/interfaces/element/isElementList.ts","../src/interfaces/editor/isBlock.ts","../src/utils/match.ts","../src/interfaces/editor/getAboveNode.ts","../src/interfaces/editor/unhangRange.ts","../src/interfaces/editor/getNodeEntries.ts","../src/interfaces/editor/getParentNode.ts","../src/interfaces/editor/getPreviousNode.ts","../src/interfaces/editor/isElementEmpty.ts","../src/interfaces/editor/withoutNormalizing.ts","../src/interfaces/text/isText.ts","../src/interfaces/node/hasSingleChild.ts","../src/interfaces/transforms/deleteText.ts","../src/interfaces/transforms/moveNodes.ts","../src/interfaces/transforms/removeNodes.ts","../src/interfaces/transforms/select.ts","../src/interfaces/transforms/mergeNodes.ts","../src/interfaces/editor/getEndPoint.ts","../src/interfaces/editor/getLeafNode.ts","../src/interfaces/editor/getPointAfter.ts","../src/interfaces/editor/getPointBefore.ts","../src/interfaces/editor/getStartPoint.ts","../src/interfaces/editor/getVoidNode.ts","../src/interfaces/editor/isVoid.ts","../src/interfaces/editor/deleteMerge.ts","../src/interfaces/editor/getEdgePoints.ts","../src/interfaces/editor/getEditorString.ts","../src/interfaces/editor/getFirstNode.ts","../src/interfaces/editor/getFragment.ts","../src/interfaces/editor/getLastNode.ts","../src/interfaces/editor/getLevels.ts","../src/interfaces/editor/getMarks.ts","../src/interfaces/editor/getNextNode.ts","../src/interfaces/editor/getNodeEntry.ts","../src/interfaces/editor/getPath.ts","../src/interfaces/editor/getPathRefs.ts","../src/interfaces/editor/getPoint.ts","../src/interfaces/editor/getPointRefs.ts","../src/interfaces/editor/getPositions.ts","../src/interfaces/editor/getRange.ts","../src/interfaces/editor/getRangeRefs.ts","../src/interfaces/editor/hasBlocks.ts","../src/interfaces/editor/hasInlines.ts","../src/interfaces/editor/hasTexts.ts","../src/interfaces/editor/insertBreak.ts","../src/interfaces/editor/insertNode.ts","../src/interfaces/editor/isEdgePoint.ts","../src/interfaces/editor/isEditor.ts","../src/interfaces/editor/isEditorNormalizing.ts","../src/interfaces/editor/isEndPoint.ts","../src/interfaces/editor/isInline.ts","../src/interfaces/editor/isStartPoint.ts","../src/interfaces/editor/isMarkableVoid.ts","../src/interfaces/editor/normalizeEditor.ts","../src/interfaces/editor/removeEditorMark.ts","../src/interfaces/history-editor/isHistoryEditor.ts","../src/interfaces/history-editor/isHistoryMerging.ts","../src/interfaces/history-editor/isHistorySaving.ts","../src/interfaces/history-editor/withoutMergingHistory.ts","../src/interfaces/history-editor/withoutSavingHistory.ts","../src/interfaces/node/TDescendant.ts","../src/interfaces/node/getCommonNode.ts","../src/interfaces/text/isTextList.ts","../src/interfaces/text/textEquals.ts","../src/interfaces/text/textMatches.ts","../src/interfaces/node/getNode.ts","../src/interfaces/node/getNodeAncestor.ts","../src/interfaces/node/getNodeAncestors.ts","../src/interfaces/node/getNodeChild.ts","../src/interfaces/node/getNodeChildren.ts","../src/interfaces/node/getNodeDescendant.ts","../src/interfaces/node/getNodeDescendants.ts","../src/interfaces/node/getNodeElements.ts","../src/interfaces/node/getNodeFirstNode.ts","../src/interfaces/node/getNodeFragment.ts","../src/interfaces/node/getNodeLastNode.ts","../src/interfaces/node/getNodeLeaf.ts","../src/interfaces/node/getNodeLevels.ts","../src/interfaces/node/getNodeParent.ts","../src/interfaces/node/getNodeProps.ts","../src/interfaces/node/getNodeString.ts","../src/interfaces/node/getNodeTexts.ts","../src/interfaces/node/getNodes.ts","../src/interfaces/node/hasNode.ts","../src/interfaces/node/isAncestor.ts","../src/interfaces/node/isNode.ts","../src/interfaces/node/isNodeList.ts","../src/interfaces/node/nodeMatches.ts","../src/interfaces/range/isCollapsed.ts","../src/interfaces/range/isExpanded.ts","../src/interfaces/transforms/collapseSelection.ts","../src/interfaces/transforms/deselect.ts","../src/interfaces/transforms/insertFragment.ts","../src/interfaces/transforms/insertNodes.ts","../src/interfaces/transforms/insertText.ts","../src/interfaces/transforms/liftNodes.ts","../src/interfaces/transforms/moveSelection.ts","../src/interfaces/transforms/setNodes.ts","../src/interfaces/transforms/setPoint.ts","../src/interfaces/transforms/setSelection.ts","../src/interfaces/transforms/splitNodes.ts","../src/interfaces/transforms/unsetNodes.ts","../src/interfaces/transforms/unwrapNodes.ts","../src/interfaces/transforms/wrapNodes.ts","../src/utils/queryNode.ts","../src/queries/findNode.ts","../src/queries/someNode.ts","../src/transforms/addRangeMarks.ts","../src/transforms/setElements.ts","../src/transforms/unhangCharacterRange.ts"],"sourcesContent":["import { createEditor } from 'slate';\n\nimport { TEditor, Value } from './interfaces/editor/TEditor';\n\nexport const createTEditor = <V extends Value>() =>\n  createEditor() as any as TEditor<V>;\n","import { Modify, UnknownObject } from '@udecode/utils';\nimport { Editor, Path } from 'slate';\n\nimport { TOperation } from '../../types/TOperation';\nimport { EElement, EElementOrText, TElement } from '../element/TElement';\nimport { TDescendant } from '../node/TDescendant';\nimport { ENode, TNode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\n\nexport type Value = TElement[];\n\n/**\n * A helper type for getting the value of an editor.\n */\nexport type ValueOf<E extends TEditor> = E['children'];\n\nexport type TEditor<V extends Value = Value> = Modify<\n  Editor,\n  {\n    id: any;\n    children: V;\n    operations: TOperation[];\n    marks: Record<string, any> | null;\n\n    // Schema-specific node behaviors.\n    isInline: <N extends TElement>(element: N) => boolean;\n    isVoid: <N extends TElement>(element: N) => boolean;\n    markableVoid: <N extends TElement>(element: N) => boolean;\n    normalizeNode: <N extends TNode>(entry: TNodeEntry<N>) => void;\n\n    // Overrideable core actions.\n    apply: <N extends TDescendant>(operation: TOperation<N>) => void;\n    getFragment: <N extends TDescendant>() => N[];\n    insertFragment: <N extends TDescendant>(fragment: N[]) => void;\n    insertNode: <N extends TDescendant>(node: N) => void;\n    getDirtyPaths: <N extends TDescendant>(operation: TOperation<N>) => Path[];\n  }\n> &\n  UnknownObject;\n\n/**\n * Get editor with typed methods and operations.\n * Note that it can't be used as a parameter of type TEditor.\n */\nexport const getTEditor = <V extends Value, E extends TEditor<V> = TEditor<V>>(\n  editor: E\n) =>\n  editor as Modify<\n    E,\n    {\n      operations: TOperation<EElementOrText<V>>[];\n\n      // Schema-specific node behaviors.\n      isInline: (element: EElement<V>) => boolean;\n      isVoid: (element: EElement<V>) => boolean;\n      normalizeNode: (entry: TNodeEntry<ENode<V>>) => void;\n\n      // Overrideable core actions.\n      apply: (operation: TOperation<EElementOrText<V>>) => void;\n      getFragment: () => EElementOrText<V>[];\n      insertFragment: (fragment: EElementOrText<V>[]) => void;\n      insertNode: (node: EElementOrText<V> | EElementOrText<V>[]) => void;\n    }\n  >;\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Add a custom property to the leaf text nodes in the current selection.\n *\n * If the selection is currently collapsed, the marks will be added to the\n * `editor.marks` property instead, and applied when text is inserted next.\n */\nexport const addMark = <V extends Value>(\n  editor: TEditor<V>,\n  key: string,\n  value: any\n) => Editor.addMark(editor as any, key, value);\n","import { Editor, Path } from 'slate';\nimport { EditorPathRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Path` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPathRef = <V extends Value>(\n  editor: TEditor<V>,\n  at: Path,\n  options?: EditorPathRefOptions\n) => Editor.pathRef(editor as any, at, options as any);\n","import { Editor, Point } from 'slate';\nimport { EditorPointRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Point` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPointRef = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point,\n  options?: EditorPointRefOptions\n) => Editor.pointRef(editor as any, point, options as any);\n","import { Editor, Range } from 'slate';\nimport { EditorRangeRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Range` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createRangeRef = <V extends Value>(\n  editor: TEditor<V>,\n  range: Range,\n  options?: EditorRangeRefOptions\n) => Editor.rangeRef(editor as any, range, options as any);\n","import { Editor } from 'slate';\nimport { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete content in the editor backward from the current selection.\n */\nexport const deleteBackward = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteBackward(editor as any, options);\n","import { Editor } from 'slate';\nimport { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete content in the editor forward from the current selection.\n */\nexport const deleteForward = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteForward(editor as any, options);\n","import { Editor } from 'slate';\nimport { EditorFragmentDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete the content in the current selection.\n */\nexport const deleteFragment = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorFragmentDeletionOptions\n) => Editor.deleteFragment(editor as any, options);\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isArray = require('./isArray');\n\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray(value) ? value : [value];\n}\n\nmodule.exports = castArray;\n","import { Element } from 'slate';\n\nimport { TElement } from './TElement';\n\n/**\n * Check if an element matches set of properties.\n *\n * Note: this checks custom properties, and it does not ensure that any\n * children are equivalent.\n */\nexport const elementMatches = (element: TElement, props: object) =>\n  Element.matches(element, props);\n","import { Element } from 'slate';\n\nimport { TElement } from './TElement';\n\n/**\n * Check if a value implements the 'Element' interface.\n */\nexport const isElement = (value: any): value is TElement =>\n  Element.isElement(value);\n","import { Element } from 'slate';\n\nimport { TElement } from './TElement';\n\n/**\n * Check if a value is an array of `Element` objects.\n */\nexport const isElementList = (value: any): value is TElement[] =>\n  Element.isElementList(value);\n","import { Editor } from 'slate';\n\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is a block `Element` object.\n */\nexport const isBlock = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => isElement(value) && Editor.isBlock(editor as any, value);\n","import { castArray } from 'lodash';\n\nimport { isBlock } from '../interfaces/editor/isBlock';\nimport { TEditor, Value } from '../interfaces/editor/TEditor';\nimport { ENode, TNode } from '../interfaces/node/TNode';\nimport { TPath } from '../types/interfaces';\n\nexport type PredicateObj = Record<string, any | any[]>;\nexport type PredicateFn<T extends TNode> = (obj: T, path: TPath) => boolean;\nexport type Predicate<T extends TNode> = PredicateObj | PredicateFn<T>;\n\n/**\n * Match the object with a predicate object or function.\n * If predicate is:\n * - object: every predicate key/value should be in obj.\n * - function: it should return true.\n */\nexport const match = <T extends TNode>(\n  obj: T,\n  path: TPath,\n  predicate?: Predicate<T>\n): boolean => {\n  if (!predicate) return true;\n\n  if (typeof predicate === 'object') {\n    return Object.entries(predicate).every(([key, value]) => {\n      const values = castArray<any>(value);\n\n      return values.includes(obj[key]);\n    });\n  }\n\n  return predicate(obj, path);\n};\n\n/**\n * Extended query options for slate queries:\n * - `match` can be an object predicate where one of the values should include the node value.\n * Example: { type: ['1', '2'] } will match the nodes having one of these 2 types.\n */\nexport const getQueryOptions = <V extends Value>(\n  editor: TEditor<V>,\n  options: any = {}\n) => {\n  const { match: _match, block } = options;\n\n  return {\n    ...options,\n    match:\n      _match || block\n        ? (n: ENode<V>, path: TPath) =>\n            match(n, path, _match) && (!block || isBlock(editor, n))\n        : undefined,\n  };\n};\n\nexport type ENodeMatch<N extends TNode> = Predicate<N>;\n\nexport interface ENodeMatchOptions<V extends Value = Value> {\n  match?: ENodeMatch<ENode<V>>;\n  block?: boolean;\n}\n","import { Modify } from '@udecode/utils';\nimport { Editor } from 'slate';\nimport { EditorAboveOptions } from 'slate/dist/interfaces/editor';\n\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { EAncestor, TAncestor } from '../node/TAncestor';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetAboveNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorAboveOptions<TAncestor>>,\n  ENodeMatchOptions<V>\n>;\n\n/**\n * Get the ancestor above a location in the document.\n */\nexport const getAboveNode = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetAboveNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.above(editor as any, getQueryOptions(editor, options)) as any;\n","import {\n  Editor,\n  EditorUnhangRangeOptions,\n  Path,\n  Point,\n  Range,\n  Span,\n} from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\nexport type UnhangRangeOptions = EditorUnhangRangeOptions & {\n  unhang?: boolean;\n};\n\n/**\n * Convert a range into a non-hanging one if:\n * - `unhang` is true,\n * - `at` (default: selection) is a range.\n */\nexport const unhangRange = <\n  V extends Value,\n  R extends Range | Path | Point | Span | null | undefined,\n>(\n  editor: TEditor<V>,\n  range: R,\n  options: UnhangRangeOptions = {}\n): R => {\n  const { voids, unhang = true } = options;\n\n  if (Range.isRange(range) && unhang) {\n    return Editor.unhangRange(editor as any, range, { voids }) as R;\n  }\n\n  return range;\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorNodesOptions } from 'slate';\n\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { ENode, TNode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\nimport { unhangRange, UnhangRangeOptions } from './unhangRange';\n\nexport type GetNodeEntriesOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorNodesOptions<TNode>>,\n  ENodeMatchOptions<V>\n> &\n  UnhangRangeOptions;\n\n/**\n * Iterate through all of the nodes in the Editor.\n */\nexport const getNodeEntries = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetNodeEntriesOptions<V>\n): Generator<TNodeEntry<N>, void, undefined> => {\n  unhangRange(editor, options?.at, options);\n\n  return Editor.nodes(editor as any, getQueryOptions(editor, options)) as any;\n};\n","import { Editor, EditorParentOptions, Location } from 'slate';\n\nimport { EAncestor } from '../node/TAncestor';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the parent node of a location.\n * Returns undefined if there is no parent.\n */\nexport const getParentNode = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorParentOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.parent(editor as any, at, options) as any;\n  } catch (error) {}\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorPreviousOptions } from 'slate';\n\nimport { ENode, TNode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetPreviousNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorPreviousOptions<TNode>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Get the matching node in the branch of the document before a location.\n */\nexport const getPreviousNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetPreviousNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.previous(editor as any, options as any) as any;\n","import { Editor } from 'slate';\n\nimport { EElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if an element is empty, accounting for void nodes.\n */\nexport const isElementEmpty = <V extends Value>(\n  editor: TEditor<V>,\n  element: EElement<V>\n) => Editor.isEmpty(editor as any, element);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Call a function, deferring normalization until after it completes\n * @return true if normalized.\n */\nexport const withoutNormalizing = <V extends Value>(\n  editor: TEditor<V>,\n  fn: () => boolean | void\n) => {\n  let normalized = false;\n\n  Editor.withoutNormalizing(editor as any, () => {\n    normalized = !!fn();\n  });\n\n  return normalized;\n};\n","import { Text } from 'slate';\n\nimport { TText } from './TText';\n\n/**\n * Check if a value implements the `Text` interface.\n */\nexport const isText = (value: any): value is TText => Text.isText(value);\n","import { isText } from '../text/isText';\nimport { TNode } from './TNode';\n\nexport const hasSingleChild = <N extends TNode>(node: N): boolean => {\n  if (isText(node)) {\n    return true;\n  }\n  return node.children.length === 1 && hasSingleChild(node.children[0]);\n};\n","import { Transforms } from 'slate';\nimport { TextDeleteOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Delete content in the editor.\n */\nexport const deleteText = <V extends Value>(\n  editor: TEditor<V>,\n  options?: TextDeleteOptions\n) => {\n  Transforms.delete(editor as any, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type MoveNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.moveNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Move the nodes at a location to a new location.\n */\nexport const moveNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: MoveNodesOptions<V>\n) => Transforms.moveNodes(editor as any, options as any);\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type RemoveNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.removeNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Remove the nodes at a specific location in the document.\n */\nexport const removeNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: RemoveNodesOptions<V>\n) => Transforms.removeNodes(editor as any, options as any);\n","import { Location, Transforms } from 'slate';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set the selection to a new value.\n */\nexport const select = <V extends Value>(\n  editor: TEditor<V>,\n  target: Location\n) => {\n  Transforms.select(editor as any, target);\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor, Element, Path, Range, Text, Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { createPathRef } from '../editor/createPathRef';\nimport { createPointRef } from '../editor/createPointRef';\nimport { getAboveNode } from '../editor/getAboveNode';\nimport { getNodeEntries } from '../editor/getNodeEntries';\nimport { getParentNode } from '../editor/getParentNode';\nimport { getPreviousNode } from '../editor/getPreviousNode';\nimport { isBlock } from '../editor/isBlock';\nimport { isElementEmpty } from '../editor/isElementEmpty';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { withoutNormalizing } from '../editor/withoutNormalizing';\nimport { isElement } from '../element/isElement';\nimport { hasSingleChild } from '../node/hasSingleChild';\nimport { isText } from '../text/isText';\nimport { deleteText } from './deleteText';\nimport { moveNodes } from './moveNodes';\nimport { removeNodes } from './removeNodes';\nimport { select } from './select';\n\nexport type MergeNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.mergeNodes>[1]>,\n  NodeMatchOption<V>\n> & {\n  /**\n   * Default: if the node isn't already the next sibling of the previous node, move\n   * it so that it is before merging.\n   */\n  mergeNode?: (editor: TEditor<V>, options: { at: Path; to: Path }) => void;\n\n  /**\n   * Default: if there was going to be an empty ancestor of the node that was merged,\n   * we remove it from the tree.\n   */\n  removeEmptyAncestor?: (editor: TEditor<V>, options: { at: Path }) => void;\n};\n\n/**\n * Merge a node at a location with the previous node of the same depth,\n * removing any empty containing nodes after the merge if necessary.\n */\nexport const mergeNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options: MergeNodesOptions<V> = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    let { match, at = editor.selection } = options;\n    const {\n      mergeNode,\n      removeEmptyAncestor,\n      hanging = false,\n      voids = false,\n      mode = 'lowest',\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = getParentNode(editor, at)!;\n        match = (n) => parent.children.includes(n as any);\n      } else {\n        match = (n) => isBlock(editor as any, n);\n      }\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor as any, at);\n    }\n\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end] = Range.edges(at);\n        const pointRef = createPointRef(editor as any, end);\n        deleteText(editor, { at });\n        at = pointRef.unref()!;\n\n        if (options.at == null) {\n          select(editor as any, at);\n        }\n      }\n    }\n\n    const _nodes = getNodeEntries(editor as any, { at, match, voids, mode });\n    const [current] = Array.from(_nodes);\n    const prev = getPreviousNode(editor as any, { at, match, voids, mode });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    const newPath = Path.next(prevPath);\n    const commonPath = Path.common(path, prevPath);\n    const isPreviousSibling = Path.isSibling(path, prevPath);\n    const _levels = Editor.levels(editor as any, { at: path });\n    const levels = new Set(\n      Array.from(_levels, ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n    );\n\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    const emptyAncestor = getAboveNode(editor as any, {\n      at: path,\n      mode: 'highest',\n      match: (n) => levels.has(n) && isElement(n) && hasSingleChild(n),\n    });\n\n    const emptyRef =\n      emptyAncestor && createPathRef(editor as any, emptyAncestor[1]);\n    let properties;\n    let position;\n\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (isText(node) && isText(prevNode)) {\n      const { text, ...rest } = node;\n      position = prevNode.text.length;\n      properties = rest as Partial<Text>;\n    } else if (isElement(node) && isElement(prevNode)) {\n      const { children, ...rest } = node;\n      position = prevNode.children.length;\n      properties = rest as Partial<Element>;\n    } else {\n      throw new Error(\n        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n          node\n        )} ${JSON.stringify(prevNode)}`\n      );\n    }\n\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (\n      !isPreviousSibling && // DIFF\n      !mergeNode\n    ) {\n      moveNodes(editor, { at: path, to: newPath, voids });\n    }\n\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      // DIFF: start\n      if (removeEmptyAncestor) {\n        const emptyPath = emptyRef.current;\n        emptyPath && removeEmptyAncestor(editor as any, { at: emptyPath });\n      } else {\n        removeNodes(editor, { at: emptyRef.current!, voids });\n      }\n      // DIFF: end\n    }\n\n    // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // DIFF: start\n    if (mergeNode) {\n      mergeNode(editor as any, { at: path, to: newPath });\n      // DIFF: end\n    } else if (\n      (isElement(prevNode) && isElementEmpty(editor as any, prevNode)) ||\n      (isText(prevNode) && prevNode.text === '')\n    ) {\n      removeNodes(editor, { at: prevPath, voids });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties,\n      });\n    }\n\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n","import { Editor, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the end point of a location.\n */\nexport const getEndPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.end(editor as any, at);\n","import { Editor, Location } from 'slate';\nimport { EditorLeafOptions } from 'slate/dist/interfaces/editor';\n\nimport { ETextEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the leaf text node at a location.\n */\nexport const getLeafNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorLeafOptions\n): ETextEntry<V> => Editor.leaf(editor as any, at, options) as any;\n","import { Editor, EditorAfterOptions, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the point after a location.\n */\nexport const getPointAfter = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorAfterOptions\n) => Editor.after(editor as any, at, options);\n","import { Editor, EditorBeforeOptions, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the point before a location.\n */\nexport const getPointBefore = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorBeforeOptions\n) => Editor.before(editor as any, at, options);\n","import { Editor, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start point of a location.\n */\nexport const getStartPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.start(editor as any, at);\n","import { Editor, EditorVoidOptions } from 'slate';\n\nimport { EElement } from '../element/TElement';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Match a void node in the current branch of the editor.\n */\nexport const getVoidNode = <N extends EElement<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: EditorVoidOptions\n): TNodeEntry<N> | undefined => Editor.void(editor as any, options) as any;\n","import { Editor } from 'slate';\n\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is a void `Element` object.\n */\nexport const isVoid = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => {\n  return isElement(value) && Editor.isVoid(editor as any, value);\n};\n","import { Editor, Location, Path, Point, Range } from 'slate';\n\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { mergeNodes } from '../transforms/mergeNodes';\nimport { removeNodes } from '../transforms/removeNodes';\nimport { select } from '../transforms/select';\nimport { createPathRef } from './createPathRef';\nimport { createPointRef } from './createPointRef';\nimport { getAboveNode } from './getAboveNode';\nimport { getEndPoint } from './getEndPoint';\nimport { getLeafNode } from './getLeafNode';\nimport { getNodeEntries } from './getNodeEntries';\nimport { getPointAfter } from './getPointAfter';\nimport { getPointBefore } from './getPointBefore';\nimport { getStartPoint } from './getStartPoint';\nimport { getVoidNode } from './getVoidNode';\nimport { isBlock } from './isBlock';\nimport { isVoid } from './isVoid';\nimport { TEditor, Value } from './TEditor';\nimport { withoutNormalizing } from './withoutNormalizing';\n\nexport const deleteMerge = <V extends Value>(\n  editor: TEditor<V>,\n  options: {\n    at?: Location;\n    distance?: number;\n    unit?: 'character' | 'word' | 'line' | 'block';\n    reverse?: boolean;\n    hanging?: boolean;\n    voids?: boolean;\n    test?: any;\n  } = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    const {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false,\n    } = options;\n    let { at = editor.selection, hanging = false } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      at = at.anchor;\n    }\n\n    if (Point.isPoint(at)) {\n      const furthestVoid = getVoidNode(editor as any, { at, mode: 'highest' });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = { unit, distance };\n        const target = reverse\n          ? getPointBefore(editor as any, at, opts) ||\n            getStartPoint(editor as any, [])\n          : getPointAfter(editor as any, at, opts) ||\n            getEndPoint(editor as any, []);\n        at = { anchor: at, focus: target };\n        hanging = true;\n      }\n    }\n\n    if (Path.isPath(at)) {\n      removeNodes(editor, { at, voids });\n      return;\n    }\n\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n\n    if (!hanging) {\n      at = Editor.unhangRange(editor as any, at, { voids });\n    }\n\n    let [start, end] = Range.edges(at);\n    const startBlock = getAboveNode(editor, {\n      match: (n) => isBlock(editor as any, n),\n      at: start,\n      voids,\n    });\n    const endBlock = getAboveNode(editor, {\n      match: (n) => isBlock(editor as any, n),\n      at: end,\n      voids,\n    });\n    const isAcrossBlocks =\n      startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    const isSingleText = Path.equals(start.path, end.path);\n    const startVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: start, mode: 'highest' });\n    const endVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: end, mode: 'highest' });\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startVoid) {\n      const before = getPointBefore(editor as any, start);\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n\n    if (endVoid) {\n      const after = getPointAfter(editor as any, end);\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: TNodeEntry[] = [];\n    let lastPath: Path | undefined;\n\n    const _nodes = getNodeEntries(editor as any, { at, voids });\n    for (const entry of _nodes) {\n      const [node, path] = entry;\n\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n\n      if (\n        (!voids && isVoid(editor as any, node)) ||\n        (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n      ) {\n        matches.push(entry as any);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) =>\n      createPathRef(editor as any, p)\n    );\n    const startRef = createPointRef(editor as any, start);\n    const endRef = createPointRef(editor as any, end);\n\n    if (!isSingleText && !startVoid) {\n      const point = startRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const { offset } = start;\n      const text = node.text.slice(offset);\n      editor.apply({ type: 'remove_text', path, offset, text });\n    }\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!;\n      removeNodes(editor, { at: path, voids });\n    }\n\n    if (!endVoid) {\n      const point = endRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      editor.apply({ type: 'remove_text', path, offset, text });\n    }\n\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      // DIFF: allow custom mergeNodes\n      mergeNodes(editor as any, {\n        at: endRef.current,\n        hanging: true,\n        voids,\n      });\n    }\n\n    const point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      select(editor as any, point);\n    }\n  });\n};\n","import { Editor, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start and end points of a location.\n */\nexport const getEdgePoints = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.edges(editor as any, at);\n","import { Editor, Location } from 'slate';\nimport { EditorStringOptions } from 'slate/dist/interfaces/editor';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the text string content of a location.\n *\n * Note: by default the text of void nodes is considered to be an empty\n * string, regardless of content, unless you pass in true for the voids option\n */\nexport const getEditorString = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location | null | undefined,\n  options?: EditorStringOptions\n) => {\n  if (!at) return '';\n\n  try {\n    return Editor.string(editor as any, at, options);\n  } catch (error) {\n    return '';\n  }\n};\n","import { Editor, Location } from 'slate';\n\nimport { ENodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the first node at a location.\n */\nexport const getFirstNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): ENodeEntry<V> => Editor.first(editor as any, at) as any;\n","import { Editor, Location } from 'slate';\n\nimport { EElementOrText } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the fragment at a location.\n */\nexport const getFragment = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): EElementOrText<V>[] => Editor.fragment(editor as any, at) as any;\n","import { Editor, Location } from 'slate';\n\nimport { ENodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the last node at a location.\n */\nexport const getLastNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): ENodeEntry<V> => Editor.last(editor as any, at) as any;\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorLevelsOptions } from 'slate';\n\nimport { ENode, TNode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetLevelsOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorLevelsOptions<TNode>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Iterate through all of the levels at a location.\n */\nexport const getLevels = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetLevelsOptions<V>\n): Generator<TNodeEntry<N>, void, undefined> =>\n  Editor.levels(editor as any, options as any) as any;\n","import { Editor } from 'slate';\n\nimport { EMarks } from '../text/TText';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the marks that would be added to text at the current selection.\n */\nexport const getMarks = <V extends Value>(editor: TEditor<V>) =>\n  Editor.marks(editor as any) as EMarks<V> | null;\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorNextOptions } from 'slate';\n\nimport { TDescendant } from '../node';\nimport { ENode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetNextNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorNextOptions<TDescendant>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Get the matching node in the branch of the document after a location.\n */\nexport const getNextNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetNextNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.next(editor as any, options as any) as any;\n","import { Editor, EditorNodeOptions, Location } from 'slate';\n\nimport { ENode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the node at a location.\n */\nexport const getNodeEntry = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorNodeOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.node(editor as any, at, options) as any;\n  } catch (error) {}\n};\n","import { Editor, EditorPathOptions, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the path of a location.\n */\nexport const getPath = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorPathOptions\n) => Editor.path(editor as any, at, options as any);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked path refs of the editor.\n */\nexport const getPathRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.pathRefs(editor as any);\n","import { Editor, EditorPointOptions, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start or end point of a location.\n */\nexport const getPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorPointOptions\n) => Editor.point(editor as any, at, options);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked point refs of the editor.\n */\nexport const getPointRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.pointRefs(editor as any);\n","import { Editor, EditorPositionsOptions } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Iterate through all of the positions in the document where a `Point` can be\n * placed.\n *\n * By default it will move forward by individual offsets at a time,  but you\n * can pass the `unit: 'character'` option to moved forward one character, word,\n * or line at at time.\n *\n * Note: By default void nodes are treated as a single point and iteration\n * will not happen inside their content unless you pass in true for the\n * voids option, then iteration will occur.\n */\nexport const getPositions = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorPositionsOptions\n) => Editor.positions(editor as any, options);\n","import { Editor, Location } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get a range of a location.\n */\nexport const getRange = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  to?: Location\n) => Editor.range(editor as any, at, to);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked range refs of the editor.\n */\nexport const getRangeRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.rangeRefs(editor as any);\n","import { Editor } from 'slate';\n\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has block children.\n */\nexport const hasBlocks = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasBlocks(editor as any, element);\n","import { Editor } from 'slate';\n\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has inline and text children.\n */\nexport const hasInlines = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasInlines(editor as any, element);\n","import { Editor } from 'slate';\n\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has text children.\n */\nexport const hasTexts = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasTexts(editor as any, element);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Insert a block break at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertBreak = <V extends Value>(editor: TEditor<V>) =>\n  Editor.insertBreak(editor as any);\n","import { Editor } from 'slate';\n\nimport { EElementOrText } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Insert a node at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertNode = <V extends Value>(\n  editor: TEditor<V>,\n  node: EElementOrText<V> | EElementOrText<V>[]\n) => Editor.insertNode(editor as any, node as any);\n","import { Editor, Location, Point } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is an edge of a location.\n */\nexport const isEdgePoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point,\n  at: Location\n) => Editor.isEdge(editor as any, point, at);\n","import { Editor } from 'slate';\n\nimport { TEditor } from './TEditor';\n\n/**\n * Check if a value is an `Editor` object.\n */\nexport const isEditor = (value: any): value is TEditor =>\n  Editor.isEditor(value);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if the editor is currently normalizing after each operation.\n */\nexport const isEditorNormalizing = <V extends Value>(editor: TEditor<V>) =>\n  Editor.isNormalizing(editor as any);\n","import { Editor, Location, Point } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is the end point of a location.\n * If point is null, return false.\n */\nexport const isEndPoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isEnd(editor as any, point, at);\n","import { Editor } from 'slate';\n\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is an inline `Element` object.\n */\nexport const isInline = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => isElement(value) && Editor.isInline(editor as any, value);\n","import { Editor, Location, Point } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is the start point of a location.\n * If point is null, return false.\n */\nexport const isStartPoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isStart(editor as any, point, at);\n","import { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is a markable void `Element` object.\n */\nexport const isMarkableVoid = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => {\n  return isElement(value) && editor.markableVoid(value);\n};\n","import { Editor, EditorNormalizeOptions } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Normalize any dirty objects in the editor.\n */\nexport const normalizeEditor = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorNormalizeOptions\n) => Editor.normalize(editor as any, options);\n","import { Editor } from 'slate';\n\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Remove a custom property from all of the leaf text nodes in the current\n * selection.\n *\n * If the selection is currently collapsed, the removal will be stored on\n * `editor.marks` and applied to the text inserted next.\n */\nexport const removeEditorMark = <V extends Value>(\n  editor: TEditor<V>,\n  key: string\n) => Editor.removeMark(editor as any, key);\n","import { HistoryEditor } from 'slate-history';\n\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isHistoryEditor}\n */\nexport const isHistoryEditor = (value: any): value is THistoryEditor =>\n  HistoryEditor.isHistoryEditor(value as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isMerging}\n */\nexport const isHistoryMerging = <V extends Value>(editor: THistoryEditor<V>) =>\n  HistoryEditor.isMerging(editor as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isSaving}\n */\nexport const isHistorySaving = <V extends Value>(editor: THistoryEditor<V>) =>\n  HistoryEditor.isSaving(editor as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.withoutMerging}\n */\nexport const withoutMergingHistory = <V extends Value>(\n  editor: THistoryEditor<V>,\n  fn: () => void\n) => HistoryEditor.withoutMerging(editor as any, fn);\n","import { HistoryEditor } from 'slate-history';\n\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.withoutSaving}\n */\nexport const withoutSavingHistory = <V extends Value>(\n  editor: THistoryEditor<V>,\n  fn: () => void\n) => HistoryEditor.withoutSaving(editor as any, fn);\n","import { TEditor, Value } from '../editor/TEditor';\nimport { isElement } from '../element/isElement';\nimport { ElementOf, TElement } from '../element/TElement';\nimport { isText } from '../text/isText';\nimport { TextOf, TText } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\nexport type TDescendant = TElement | TText;\n\n/**\n * Descendant of an editor.\n */\nexport type EDescendant<V extends Value> = DescendantOf<TEditor<V>>;\n\n/**\n * A utility type to get all the descendant node types from a root node type.\n */\nexport type DescendantOf<N extends TNode> = N extends TEditor\n  ? ElementOf<N> | TextOf<N>\n  : N extends TElement\n  ? ElementOf<N['children'][number]> | TextOf<N>\n  : never;\n\n/**\n * A utility type to get the child node types from a root node type.\n */\nexport type ChildOf<\n  N extends TNode,\n  I extends number = number,\n> = N extends TEditor\n  ? N['children'][I]\n  : N extends TElement\n  ? N['children'][I]\n  : never;\n\nexport const isDescendant: (value: any) => value is TDescendant = ((\n  node: any\n) => isElement(node) || isText(node)) as any;\n","import { Node, Path } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get an entry for the common ancesetor node of two paths.\n */\nexport const getCommonNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  another: Path\n) => Node.common(root, path, another) as TNodeEntry<N>;\n","import { Text } from 'slate';\n\nimport { TText } from './TText';\n\n/**\n * Check if a value is a list of `Text` objects.\n */\nexport const isTextList = (value: any): value is TText[] =>\n  Text.isTextList(value);\n","import { Text } from 'slate';\n\nimport { TText } from './TText';\n\n/**\n * Check if two text nodes are equal.\n */\nexport const textEquals = (text: TText, another: TText) =>\n  Text.equals(text, another);\n","import { Text } from 'slate';\n\nimport { TText } from './TText';\n\n/**\n * Check if an text matches set of properties.\n *\n * Note: this is for matching custom properties, and it does not ensure that\n * the `text` property are two nodes equal.\n */\nexport const textMatches = <T extends TText>(text: T, props: object) =>\n  Text.matches(text, props);\n","import { Path } from 'slate';\n\nimport { isText } from '../text';\nimport { NodeOf, TNode } from './TNode';\n\n/**\n * Get the descendant node referred to by a specific path.\n * If the path is an empty array, it refers to the root node itself.\n * If the node is not found, return null.\n * Based on Slate get and has, performance optimization without overhead of\n * stringify on throwing\n */\nexport const getNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => {\n  try {\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i];\n\n      if (isText(root) || !root.children[p]) {\n        return null;\n      }\n\n      root = root.children[p] as R;\n    }\n\n    return root as N;\n  } catch (error) {\n    return null;\n  }\n};\n","import { Node, Path } from 'slate';\n\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, asserting that it's an ancestor node.\n */\nexport const getNodeAncestor = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path\n) => Node.ancestor(root, path) as N;\n","import { Node, NodeAncestorsOptions, Path } from 'slate';\n\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the ancestor nodes above a specific path.\n *\n * By default the order is bottom-up, from lowest to highest ancestor in\n * the tree, but you can pass the `reverse: true` option to go top-down.\n */\nexport const getNodeAncestors = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path,\n  options?: NodeAncestorsOptions\n) =>\n  Node.ancestors(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node } from 'slate';\n\nimport { ChildOf } from './TDescendant';\nimport { TNode } from './TNode';\n\n/**\n * Get the child of a node at a specific index.\n */\nexport const getNodeChild = <\n  N extends ChildOf<R, I>,\n  R extends TNode = TNode,\n  I extends number = number,\n>(\n  root: R,\n  index: I\n) => Node.child(root, index) as N;\n","import { Node, NodeChildrenOptions, Path } from 'slate';\n\nimport { ChildOf } from './TDescendant';\nimport { TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Iterate over the children of a node at a specific path.\n */\nexport const getNodeChildren = <N extends ChildOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeChildrenOptions\n) =>\n  Node.children(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node, Path } from 'slate';\n\nimport { DescendantOf } from './TDescendant';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, asserting that it's a descendant node.\n */\nexport const getNodeDescendant = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path\n) => Node.descendant(root, path) as N;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeDescendantsOptions } from 'slate';\n\nimport { DescendantOf } from './TDescendant';\nimport { TNode } from './TNode';\nimport { TDescendantEntry, TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the descendant node entries inside a root node.\n */\nexport const getNodeDescendants = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeDescendantsOptions>,\n    {\n      pass?: (node: TDescendantEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.descendants(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeElementsOptions } from 'slate';\n\nimport { ElementOf } from '../element/TElement';\nimport { TNode } from './TNode';\nimport { TElementEntry, TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the element nodes inside a root node. Each iteration\n * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n * root node is an element it will be included in the iteration as well.\n */\nexport const getNodeElements = <\n  N extends ElementOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeElementsOptions>,\n    {\n      pass?: (node: TElementEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.elements(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node, Path } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get the first node entry in a root node from a path.\n */\nexport const getNodeFirstNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.first(root, path) as TNodeEntry<N>;\n","import { Node, Range } from 'slate';\n\nimport { ElementOf } from '../element/TElement';\nimport { TextOf } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * Get the sliced fragment represented by a range inside a root node.\n */\nexport const getNodeFragment = <\n  N extends ElementOf<R> | TextOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  range: Range\n) => Node.fragment(root, range) as Array<N>;\n","import { Node, Path } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get the last node entry in a root node from a path.\n */\nexport const getNodeLastNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.last(root, path) as TNodeEntry<N>;\n","import { Node, Path } from 'slate';\n\nimport { TextOf } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, ensuring it's a leaf text node.\n */\nexport const getNodeLeaf = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.leaf(root, path) as N;\n","import { Node, NodeLevelsOptions, Path } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of the in a branch of the tree, from a specific path.\n *\n * By default the order is top-down, from lowest to highest node in the tree,\n * but you can pass the `reverse: true` option to go bottom-up.\n */\nexport const getNodeLevels = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeLevelsOptions\n) =>\n  Node.levels(root, path, options) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Node, Path } from 'slate';\n\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\n\n/**\n * Get the parent of a node at a specific path.\n */\nexport const getNodeParent = <N extends AncestorOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.parent(root, path) as N;\n","import { Node } from 'slate';\n\nimport { TNode, TNodeProps } from './TNode';\n\n/**\n * Extract the custom properties from a node.\n */\nexport const getNodeProps = <N extends TNode>(node: N) =>\n  Node.extractProps(node) as TNodeProps<N>;\n","import { Node } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Get the concatenated text string of a node's content.\n *\n * Note that this will not include spaces or line breaks between block nodes.\n * It is not a user-facing string, but a string for performing offset-related\n * computations for a node.\n */\nexport const getNodeString = (node: TNode) => Node.string(node);\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeTextsOptions } from 'slate';\n\nimport { TextOf } from '../text/TText';\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all leaf text nodes in a root node.\n */\nexport const getNodeTexts = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeTextsOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.texts(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeNodesOptions } from 'slate';\n\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the node entries of a root node. Each entry is\n * returned as a `[Node, Path]` tuple, with the path referring to the node's\n * position inside the root node.\n */\nexport const getNodes = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeNodesOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.nodes(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Node, Path } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Check if a descendant node exists at a specific path.\n */\nexport const hasNode = (root: TNode, path: Path) => Node.has(root, path);\n","import { Element } from 'slate';\n\nimport { TAncestor } from './TAncestor';\n\n/**\n * Check if a value implements the 'Ancestor' interface.\n */\nexport const isAncestor = (value: any): value is TAncestor =>\n  Element.isAncestor(value);\n","import { Node } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Check if a value implements the `Node` interface.\n */\nexport const isNode = (value: any): value is TNode => Node.isNode(value);\n","import { Node } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Check if a value is a list of `Node` objects.\n */\nexport const isNodeList = (value: any): value is TNode[] =>\n  Node.isNodeList(value);\n","import { Node } from 'slate';\n\nimport { TNode } from './TNode';\n\n/**\n * Check if a node matches a set of props.\n */\nexport const nodeMatches = (node: TNode, props: object) =>\n  Node.matches(node, props);\n","import { Range } from 'slate';\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = (range?: Range | null) =>\n  !!range && Range.isCollapsed(range);\n","import { Range } from 'slate';\n\n/**\n * See {@link Range.isExpanded}.\n * Return false if `range` is not defined.\n */\nexport const isExpanded = (range?: Range | null) =>\n  !!range && Range.isExpanded(range);\n","import { Transforms } from 'slate';\nimport { SelectionCollapseOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Collapse the selection.\n */\nexport const collapseSelection = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SelectionCollapseOptions\n) => {\n  Transforms.collapse(editor as any, options);\n};\n","import { Transforms } from 'slate';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Unset the selection.\n */\nexport const deselect = <V extends Value>(editor: TEditor<V>) => {\n  Transforms.deselect(editor as any);\n};\n","import { Transforms } from 'slate';\nimport { TextInsertFragmentOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { TEditor, Value } from '../editor/TEditor';\nimport { EElementOrText } from '../element/TElement';\n\n/**\n * Insert a fragment at a specific location in the editor.\n */\nexport const insertFragment = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  fragment: N[],\n  options?: TextInsertFragmentOptions\n) => {\n  Transforms.insertFragment(editor as any, fragment, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Path, Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { getAboveNode, getEndPoint } from '../editor';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { EElementOrText } from '../element/TElement';\n\nexport type InsertNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.insertNodes>[2]>,\n  NodeMatchOption<V>\n> & {\n  nextBlock?: boolean;\n};\n\n/**\n * Insert nodes at a specific location in the Editor.\n */\nexport const insertNodes = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  nodes: N | N[],\n  options?: InsertNodesOptions<V>\n) => {\n  if (options?.nextBlock) {\n    const at = options?.at || editor.selection;\n    if (at) {\n      const endPoint = getEndPoint(editor, at);\n      const blockEntry = getAboveNode(editor, {\n        at: endPoint,\n        block: true,\n      });\n      if (blockEntry) {\n        const nextPath = Path.next(blockEntry[1]);\n        options.at = nextPath;\n      }\n    }\n  }\n\n  Transforms.insertNodes(editor as any, nodes, options as any);\n};\n","import { Transforms } from 'slate';\nimport { TextInsertTextOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Insert a string of text in the Editor.\n */\nexport const insertText = <V extends Value>(\n  editor: TEditor<V>,\n  text: string,\n  options?: TextInsertTextOptions\n) => {\n  Transforms.insertText(editor as any, text, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type LiftNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.liftNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Lift nodes at a specific location upwards in the document tree, splitting\n * their parent in two if necessary.\n */\nexport const liftNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: LiftNodesOptions<V>\n) => Transforms.liftNodes(editor as any, options as any);\n","import { Transforms } from 'slate';\nimport { SelectionMoveOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Move the selection's point forward or backward.\n */\nexport const moveSelection = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SelectionMoveOptions\n) => {\n  Transforms.move(editor as any, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { ENode, TNodeProps } from '../node/TNode';\n\nexport type SetNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.setNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Set new properties on the nodes at a location.\n */\nexport const setNodes = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  props: Partial<TNodeProps<N>>,\n  options?: SetNodesOptions<V>\n) => Transforms.setNodes(editor as any, props, options as any);\n","import { Point, Transforms } from 'slate';\nimport { SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set new properties on one of the selection's points.\n */\nexport const setPoint = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<Point>,\n  options?: SelectionSetPointOptions\n) => {\n  Transforms.setPoint(editor as any, props, options);\n};\n","import { Range, Transforms } from 'slate';\n\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set new properties on the selection.\n */\nexport const setSelection = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<Range>\n) => {\n  Transforms.setSelection(editor as any, props);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type SplitNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.splitNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Split the nodes at a specific location.\n */\nexport const splitNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SplitNodesOptions<V>\n) => Transforms.splitNodes(editor as any, options as any);\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { ENode, TNodeProps } from '../node/TNode';\n\nexport type UnsetNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.unsetNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Unset properties on the nodes at a location.\n */\nexport const unsetNodes = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  props: keyof TNodeProps<N> | (keyof TNodeProps<N>)[],\n  options?: UnsetNodesOptions<V>\n) => {\n  return Transforms.unsetNodes(editor as any, props as any, options as any);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type UnwrapNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.unwrapNodes>[1]>,\n  ENodeMatchOptions<V>\n>;\n\n/**\n * Unwrap the nodes at a location from a parent node, splitting the parent if\n * necessary to ensure that only the content in the range is unwrapped.\n */\nexport const unwrapNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: UnwrapNodesOptions<V>\n) => {\n  Transforms.unwrapNodes(editor as any, getQueryOptions(editor, options));\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\n\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { unhangRange } from '../editor/unhangRange';\nimport { EElement } from '../element/TElement';\n\nexport type WrapNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.wrapNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Wrap the nodes at a location in a new container node, splitting the edges\n * of the range first to ensure that only the content in the range is wrapped.\n */\nexport const wrapNodes = <N extends EElement<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  element: N,\n  options?: WrapNodesOptions<V>\n) => {\n  unhangRange(editor, options?.at, options);\n\n  Transforms.wrapNodes(editor as any, element as any, options as any);\n};\n","import castArray from 'lodash/castArray';\n\nimport { TNode, TNodeEntry } from '../interfaces';\nimport { QueryNodeOptions } from '../types/QueryNodeOptions';\n\n/**\n * Query the node entry.\n */\nexport const queryNode = <N extends TNode>(\n  entry?: TNodeEntry<N>,\n  { filter, allow, exclude, level, maxLevel }: QueryNodeOptions = {}\n) => {\n  if (!entry) return false;\n\n  const [node, path] = entry;\n\n  if (level) {\n    const levels = castArray(level);\n\n    if (!levels.includes(path.length)) {\n      return false;\n    }\n  }\n\n  if (maxLevel && path.length > maxLevel) {\n    return false;\n  }\n\n  if (filter && !filter(entry)) {\n    return false;\n  }\n\n  if (allow) {\n    const allows = castArray(allow);\n\n    if (allows.length > 0 && !allows.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  if (exclude) {\n    const excludes = castArray(exclude);\n\n    if (excludes.length > 0 && excludes.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","import {\n  ENode,\n  getNodeEntries,\n  GetNodeEntriesOptions,\n  TEditor,\n  TNodeEntry,\n  Value,\n} from '../interfaces';\nimport { getQueryOptions } from '../utils';\n\nexport type FindNodeOptions<V extends Value = Value> = GetNodeEntriesOptions<V>;\n\n/**\n * Find node matching the condition.\n */\nexport const findNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V> = {}\n): TNodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const nodeEntries = getNodeEntries<N, V>(editor, {\n      at: editor.selection || [],\n      ...getQueryOptions(editor, options),\n    });\n\n    // eslint-disable-next-line no-unreachable-loop\n    for (const [node, path] of nodeEntries) {\n      return [node, path];\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\n","import { ENode, TEditor, Value } from '../interfaces';\nimport { findNode, FindNodeOptions } from './findNode';\n\n/**\n * Iterate through all of the nodes in the editor and break early for the first truthy match. Otherwise\n * returns false.\n */\nexport const someNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V>\n) => {\n  return !!findNode<N, V>(editor, options);\n};\n","import { Editor, Location, Node, Path, Range, Text, Transforms } from 'slate';\n\nimport { getRange } from '../interfaces';\nimport { TEditor, Value } from '../interfaces/editor/TEditor';\n\n/**\n * Add marks to each node of a range.\n */\nexport const addRangeMarks = <V extends Value>(\n  editor: TEditor<V>,\n  props: any,\n  {\n    at = editor.selection,\n  }: {\n    at?: Location | null;\n  } = {}\n) => {\n  if (at) {\n    if (Path.isPath(at)) {\n      at = getRange(editor as any, at);\n    }\n\n    const match = (node: Node, path: Path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n      const parentEntry = Editor.parent(editor as any, path);\n      if (!parentEntry) return false;\n\n      const [parentNode] = parentEntry;\n\n      return (\n        !editor.isVoid(parentNode as any) ||\n        editor.markableVoid(parentNode as any)\n      );\n    };\n    const isExpandedRange = Range.isExpanded(at as Range);\n    let markAcceptingVoidSelected = false;\n    if (!isExpandedRange) {\n      const selectedEntry = Editor.node(editor as any, at);\n      if (!selectedEntry) return;\n\n      const [selectedNode, selectedPath] = selectedEntry;\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const parentEntry = Editor.parent(editor as any, selectedPath);\n        if (!parentEntry) return;\n\n        const [parentNode] = parentEntry;\n\n        markAcceptingVoidSelected =\n          parentNode && editor.markableVoid(parentNode as any);\n      }\n    }\n    if (isExpandedRange || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor as any, props, {\n        match,\n        split: true,\n        voids: true,\n        at,\n      });\n    }\n    // else {\n    //   const marks = {\n    //     ...(Editor.marks(editor as any) || {}),\n    //     [key]: value,\n    //   };\n    //\n    //   editor.marks = marks;\n    //   if (!FLUSHING.get(editor as any)) {\n    //     editor.onChange();\n    //   }\n    // }\n  }\n};\n","import { TEditor, TElement, TNodeProps, Value } from '../interfaces';\nimport { setNodes, SetNodesOptions } from '../interfaces/transforms/setNodes';\n\nexport const setElements = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<TNodeProps<TElement>>,\n  options?: SetNodesOptions\n) => setNodes<TElement>(editor, props, options);\n","import { Path, Range } from 'slate';\n\nimport { getPointAfter, getPointBefore, TEditor, Value } from '../interfaces';\n\n/**\n * Unhang the range of length 1 so both edges are in the same text node.\n */\nexport const unhangCharacterRange = <V extends Value>(\n  editor: TEditor<V>,\n  at: Range\n) => {\n  let [start, end] = Range.edges(at);\n\n  if (!Path.equals(start.path, end.path)) {\n    if (end.offset === 0) {\n      const pointAfter = getPointAfter(editor, start);\n      if (pointAfter) {\n        end = pointAfter;\n      }\n    } else {\n      const pointBefore = getPointBefore(editor, end);\n      if (pointBefore) {\n        start = pointBefore;\n      }\n    }\n  }\n\n  return { anchor: start, focus: end };\n};\n"],"names":["createTEditor","createEditor","getTEditor","editor","addMark","key","value","Editor","createPathRef","at","options","pathRef","createPointRef","point","pointRef","createRangeRef","range","rangeRef","deleteBackward","deleteForward","deleteFragment","isArray","elementMatches","element","props","Element","matches","isElement","isElementList","isBlock","match","obj","path","predicate","Object","entries","every","values","_castArray","includes","getQueryOptions","_match","block","n","undefined","getAboveNode","above","unhangRange","voids","unhang","Range","isRange","getNodeEntries","nodes","getParentNode","parent","error","getPreviousNode","previous","isElementEmpty","isEmpty","withoutNormalizing","fn","normalized","isText","Text","hasSingleChild","node","children","length","deleteText","Transforms","delete","moveNodes","removeNodes","select","target","mergeNodes","selection","mergeNode","removeEmptyAncestor","hanging","mode","Path","isPath","isCollapsed","anchor","end","edges","unref","_nodes","current","Array","from","prev","prevNode","prevPath","newPath","next","commonPath","common","isPreviousSibling","isSibling","_levels","levels","Set","slice","emptyAncestor","has","emptyRef","properties","position","text","rest","Error","JSON","stringify","to","emptyPath","apply","type","getEndPoint","getLeafNode","leaf","getPointAfter","after","getPointBefore","before","getStartPoint","start","getVoidNode","void","isVoid","deleteMerge","reverse","unit","distance","Point","isPoint","furthestVoid","voidPath","opts","focus","startBlock","endBlock","isAcrossBlocks","equals","isSingleText","startVoid","endVoid","isAncestor","lastPath","entry","compare","isCommon","push","pathRefs","p","startRef","endRef","offset","getEdgePoints","getEditorString","string","getFirstNode","first","getFragment","fragment","getLastNode","last","getLevels","getMarks","marks","getNextNode","getNodeEntry","getPath","getPathRefs","getPoint","getPointRefs","pointRefs","getPositions","positions","getRange","getRangeRefs","rangeRefs","hasBlocks","hasInlines","hasTexts","insertBreak","insertNode","isEdgePoint","isEdge","isEditor","isEditorNormalizing","isNormalizing","isEndPoint","isEnd","isInline","isStartPoint","isStart","isMarkableVoid","markableVoid","normalizeEditor","normalize","removeEditorMark","removeMark","isHistoryEditor","HistoryEditor","isHistoryMerging","isMerging","isHistorySaving","isSaving","withoutMergingHistory","withoutMerging","withoutSavingHistory","withoutSaving","isDescendant","getCommonNode","root","another","Node","isTextList","textEquals","textMatches","getNode","i","getNodeAncestor","ancestor","getNodeAncestors","ancestors","getNodeChild","index","child","getNodeChildren","getNodeDescendant","descendant","getNodeDescendants","descendants","getNodeElements","elements","getNodeFirstNode","getNodeFragment","getNodeLastNode","getNodeLeaf","getNodeLevels","getNodeParent","getNodeProps","extractProps","getNodeString","getNodeTexts","texts","getNodes","hasNode","isNode","isNodeList","nodeMatches","isExpanded","collapseSelection","collapse","deselect","insertFragment","insertNodes","nextBlock","endPoint","blockEntry","nextPath","insertText","liftNodes","moveSelection","move","setNodes","setPoint","setSelection","splitNodes","unsetNodes","unwrapNodes","wrapNodes","queryNode","filter","allow","exclude","level","maxLevel","castArray","allows","excludes","findNode","nodeEntries","someNode","addRangeMarks","parentEntry","parentNode","isExpandedRange","markAcceptingVoidSelected","selectedEntry","selectedNode","selectedPath","split","setElements","unhangCharacterRange","pointAfter","pointBefore"],"mappings":";;;MAIaA,aAAa,GAAGA,MAC3BC,YAAY;;ACMd;AACA;AACA;;AA2BA;AACA;AACA;AACA;AACaC,MAAAA,UAAU,GACrBC,MAAS,IAETA;;AC3CF;AACA;AACA;AACA;AACA;AACA;MACaC,OAAO,GAAGA,CACrBD,MAAkB,EAClBE,GAAW,EACXC,KAAU,KACPC,MAAM,CAACH,OAAO,CAACD,MAAM,EAASE,GAAG,EAAEC,KAAK;;ACT7C;AACA;AACA;AACA;MACaE,aAAa,GAAGA,CAC3BL,MAAkB,EAClBM,EAAQ,EACRC,OAA8B,KAC3BH,MAAM,CAACI,OAAO,CAACR,MAAM,EAASM,EAAE,EAAEC,OAAc;;ACRrD;AACA;AACA;AACA;MACaE,cAAc,GAAGA,CAC5BT,MAAkB,EAClBU,KAAY,EACZH,OAA+B,KAC5BH,MAAM,CAACO,QAAQ,CAACX,MAAM,EAASU,KAAK,EAAEH,OAAc;;ACRzD;AACA;AACA;AACA;MACaK,cAAc,GAAGA,CAC5BZ,MAAkB,EAClBa,KAAY,EACZN,OAA+B,KAC5BH,MAAM,CAACU,QAAQ,CAACd,MAAM,EAASa,KAAK,EAAEN,OAAc;;ACRzD;AACA;AACA;AACaQ,MAAAA,cAAc,GAAGA,CAC5Bf,MAAkB,EAClBO,OAAuC,KACpCH,MAAM,CAACW,cAAc,CAACf,MAAM,EAASO,OAAO;;ACNjD;AACA;AACA;AACaS,MAAAA,aAAa,GAAGA,CAC3BhB,MAAkB,EAClBO,OAAuC,KACpCH,MAAM,CAACY,aAAa,CAAChB,MAAM,EAASO,OAAO;;ACNhD;AACA;AACA;AACaU,MAAAA,cAAc,GAAGA,CAC5BjB,MAAkB,EAClBO,OAAuC,KACpCH,MAAM,CAACa,cAAc,CAACjB,MAAM,EAASO,OAAO;;ACXjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;AAC5B;AACA,IAAA,SAAc,GAAG,OAAO;;ACvBxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS,GAAG;AACrB,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;AACzB,IAAI,OAAO,EAAE,CAAC;AACd,GAAG;AACH,EAAE,IAAI,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;AAC3B,EAAE,OAAOW,SAAO,CAAC,KAAK,CAAC,GAAG,KAAK,GAAG,CAAC,KAAK,CAAC,CAAC;AAC1C,CAAC;AACD;AACA,IAAA,WAAc,GAAG,SAAS;;ACvC1B;AACA;AACA;AACA;AACA;AACA;AACaC,MAAAA,cAAc,GAAGA,CAACC,OAAiB,EAAEC,KAAa,KAC7DC,OAAO,CAACC,OAAO,CAACH,OAAO,EAAEC,KAAK;;ACPhC;AACA;AACA;AACO,MAAMG,SAAS,GAAIrB,KAAU,IAClCmB,OAAO,CAACE,SAAS,CAACrB,KAAK;;ACJzB;AACA;AACA;AACO,MAAMsB,aAAa,GAAItB,KAAU,IACtCmB,OAAO,CAACG,aAAa,CAACtB,KAAK;;ACH7B;AACA;AACA;AACO,MAAMuB,OAAO,GAAGA,CACrB1B,MAAkB,EAClBG,KAAU,KACEqB,SAAS,CAACrB,KAAK,CAAC,IAAIC,MAAM,CAACsB,OAAO,CAAC1B,MAAM,EAASG,KAAK;;ACArE;AACA;AACA;AACA;AACA;AACA;AACO,MAAMwB,KAAK,GAAGA,CACnBC,GAAM,EACNC,IAAW,EACXC,SAAwB,KACZ;AACZ,EAAA,IAAI,CAACA,SAAS,EAAE,OAAO,IAAI,CAAA;AAE3B,EAAA,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;AACjC,IAAA,OAAOC,MAAM,CAACC,OAAO,CAACF,SAAS,CAAC,CAACG,KAAK,CAAC,CAAC,CAAC/B,GAAG,EAAEC,KAAK,CAAC,KAAK;AACvD,MAAA,MAAM+B,MAAM,GAAGC,WAAA,CAAehC,KAAK,CAAC,CAAA;MAEpC,OAAO+B,MAAM,CAACE,QAAQ,CAACR,GAAG,CAAC1B,GAAG,CAAC,CAAC,CAAA;AAClC,KAAC,CAAC,CAAA;AACJ,GAAA;AAEA,EAAA,OAAO4B,SAAS,CAACF,GAAG,EAAEC,IAAI,CAAC,CAAA;AAC7B,EAAC;;AAED;AACA;AACA;AACA;AACA;AACO,MAAMQ,eAAe,GAAGA,CAC7BrC,MAAkB,EAClBO,OAAY,GAAG,EAAE,KACd;EACH,MAAM;AAAEoB,IAAAA,KAAK,EAAEW,MAAM;AAAEC,IAAAA,KAAAA;AAAM,GAAC,GAAGhC,OAAO,CAAA;EAExC,OAAO;AACL,IAAA,GAAGA,OAAO;AACVoB,IAAAA,KAAK,EACHW,MAAM,IAAIC,KAAK,GACX,CAACC,CAAW,EAAEX,IAAW,KACvBF,KAAK,CAACa,CAAC,EAAEX,IAAI,EAAES,MAAM,CAAC,KAAK,CAACC,KAAK,IAAIb,OAAO,CAAC1B,MAAM,EAAEwC,CAAC,CAAC,CAAC,GAC1DC,SAAAA;GACP,CAAA;AACH;;ACxCA;AACA;AACA;AACO,MAAMC,YAAY,GAAGA,CAC1B1C,MAAkB,EAClBO,OAAgC,KAEhCH,MAAM,CAACuC,KAAK,CAAC3C,MAAM,EAASqC,eAAe,CAACrC,MAAM,EAAEO,OAAO,CAAC;;ACN9D;AACA;AACA;AACA;AACA;AACaqC,MAAAA,WAAW,GAAGA,CAIzB5C,MAAkB,EAClBa,KAAQ,EACRN,OAA2B,GAAG,EAAE,KAC1B;EACN,MAAM;IAAEsC,KAAK;AAAEC,IAAAA,MAAM,GAAG,IAAA;AAAK,GAAC,GAAGvC,OAAO,CAAA;EAExC,IAAIwC,KAAK,CAACC,OAAO,CAACnC,KAAK,CAAC,IAAIiC,MAAM,EAAE;AAClC,IAAA,OAAO1C,MAAM,CAACwC,WAAW,CAAC5C,MAAM,EAASa,KAAK,EAAE;AAAEgC,MAAAA,KAAAA;AAAM,KAAC,CAAC,CAAA;AAC5D,GAAA;AAEA,EAAA,OAAOhC,KAAK,CAAA;AACd;;ACpBA;AACA;AACA;MACaoC,cAAc,GAAGA,CAC5BjD,MAAkB,EAClBO,OAAkC,KACY;AAC9CqC,EAAAA,WAAW,CAAC5C,MAAM,EAAEO,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAED,EAAE,EAAEC,OAAO,CAAC,CAAA;AAEzC,EAAA,OAAOH,MAAM,CAAC8C,KAAK,CAAClD,MAAM,EAASqC,eAAe,CAACrC,MAAM,EAAEO,OAAO,CAAC,CAAC,CAAA;AACtE;;ACnBA;AACA;AACA;AACA;AACO,MAAM4C,aAAa,GAAGA,CAC3BnD,MAAkB,EAClBM,EAAY,EACZC,OAA6B,KACC;EAC9B,IAAI;IACF,OAAOH,MAAM,CAACgD,MAAM,CAACpD,MAAM,EAASM,EAAE,EAAEC,OAAO,CAAC,CAAA;AAClD,GAAC,CAAC,OAAO8C,KAAK,EAAE,EAAC;AACnB;;ACJA;AACA;AACA;AACaC,MAAAA,eAAe,GAAGA,CAC7BtD,MAAkB,EAClBO,OAAmC,KAEnCH,MAAM,CAACmD,QAAQ,CAACvD,MAAM,EAASO,OAAc;;AChB/C;AACA;AACA;AACaiD,MAAAA,cAAc,GAAGA,CAC5BxD,MAAkB,EAClBoB,OAAoB,KACjBhB,MAAM,CAACqD,OAAO,CAACzD,MAAM,EAASoB,OAAO;;ACP1C;AACA;AACA;AACA;MACasC,kBAAkB,GAAGA,CAChC1D,MAAkB,EAClB2D,EAAwB,KACrB;EACH,IAAIC,UAAU,GAAG,KAAK,CAAA;AAEtBxD,EAAAA,MAAM,CAACsD,kBAAkB,CAAC1D,MAAM,EAAS,MAAM;AAC7C4D,IAAAA,UAAU,GAAG,CAAC,CAACD,EAAE,EAAE,CAAA;AACrB,GAAC,CAAC,CAAA;AAEF,EAAA,OAAOC,UAAU,CAAA;AACnB;;ACfA;AACA;AACA;AACO,MAAMC,MAAM,GAAI1D,KAAU,IAAqB2D,IAAI,CAACD,MAAM,CAAC1D,KAAK;;ACJ1D4D,MAAAA,cAAc,GAAqBC,IAAO,IAAc;AACnE,EAAA,IAAIH,MAAM,CAACG,IAAI,CAAC,EAAE;AAChB,IAAA,OAAO,IAAI,CAAA;AACb,GAAA;AACA,EAAA,OAAOA,IAAI,CAACC,QAAQ,CAACC,MAAM,KAAK,CAAC,IAAIH,cAAc,CAACC,IAAI,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;AACvE;;ACHA;AACA;AACA;MACaE,UAAU,GAAGA,CACxBnE,MAAkB,EAClBO,OAA2B,KACxB;AACH6D,EAAAA,UAAU,CAACC,MAAM,CAACrE,MAAM,EAASO,OAAO,CAAC,CAAA;AAC3C;;ACFA;AACA;AACA;AACa+D,MAAAA,SAAS,GAAGA,CACvBtE,MAAkB,EAClBO,OAA6B,KAC1B6D,UAAU,CAACE,SAAS,CAACtE,MAAM,EAASO,OAAc;;ACNvD;AACA;AACA;AACagE,MAAAA,WAAW,GAAGA,CACzBvE,MAAkB,EAClBO,OAA+B,KAC5B6D,UAAU,CAACG,WAAW,CAACvE,MAAM,EAASO,OAAc;;ACbzD;AACA;AACA;MACaiE,MAAM,GAAGA,CACpBxE,MAAkB,EAClByE,MAAgB,KACb;AACHL,EAAAA,UAAU,CAACI,MAAM,CAACxE,MAAM,EAASyE,MAAM,CAAC,CAAA;AAC1C;;AC2BA;AACA;AACA;AACA;AACO,MAAMC,UAAU,GAAGA,CACxB1E,MAAkB,EAClBO,OAA6B,GAAG,EAAE,KACzB;EACTmD,kBAAkB,CAAC1D,MAAM,EAAS,MAAM;IACtC,IAAI;MAAE2B,KAAK;MAAErB,EAAE,GAAGN,MAAM,CAAC2E,SAAAA;AAAU,KAAC,GAAGpE,OAAO,CAAA;IAC9C,MAAM;MACJqE,SAAS;MACTC,mBAAmB;AACnBC,MAAAA,OAAO,GAAG,KAAK;AACfjC,MAAAA,KAAK,GAAG,KAAK;AACbkC,MAAAA,IAAI,GAAG,QAAA;AACT,KAAC,GAAGxE,OAAO,CAAA;IAEX,IAAI,CAACD,EAAE,EAAE;AACP,MAAA,OAAA;AACF,KAAA;IAEA,IAAIqB,KAAK,IAAI,IAAI,EAAE;AACjB,MAAA,IAAIqD,IAAI,CAACC,MAAM,CAAC3E,EAAE,CAAC,EAAE;QACnB,MAAM,CAAC8C,MAAM,CAAC,GAAGD,aAAa,CAACnD,MAAM,EAAEM,EAAE,CAAE,CAAA;QAC3CqB,KAAK,GAAIa,CAAC,IAAKY,MAAM,CAACa,QAAQ,CAAC7B,QAAQ,CAACI,CAAQ,CAAC,CAAA;AACnD,OAAC,MAAM;QACLb,KAAK,GAAIa,CAAC,IAAKd,OAAO,CAAC1B,MAAM,EAASwC,CAAC,CAAC,CAAA;AAC1C,OAAA;AACF,KAAA;IAEA,IAAI,CAACsC,OAAO,IAAI/B,KAAK,CAACC,OAAO,CAAC1C,EAAE,CAAC,EAAE;MACjCA,EAAE,GAAGF,MAAM,CAACwC,WAAW,CAAC5C,MAAM,EAASM,EAAE,CAAC,CAAA;AAC5C,KAAA;AAEA,IAAA,IAAIyC,KAAK,CAACC,OAAO,CAAC1C,EAAE,CAAC,EAAE;AACrB,MAAA,IAAIyC,KAAK,CAACmC,WAAW,CAAC5E,EAAE,CAAC,EAAE;QACzBA,EAAE,GAAGA,EAAE,CAAC6E,MAAM,CAAA;AAChB,OAAC,MAAM;QACL,MAAM,GAAGC,GAAG,CAAC,GAAGrC,KAAK,CAACsC,KAAK,CAAC/E,EAAE,CAAC,CAAA;AAC/B,QAAA,MAAMK,QAAQ,GAAGF,cAAc,CAACT,MAAM,EAASoF,GAAG,CAAC,CAAA;QACnDjB,UAAU,CAACnE,MAAM,EAAE;AAAEM,UAAAA,EAAAA;AAAG,SAAC,CAAC,CAAA;AAC1BA,QAAAA,EAAE,GAAGK,QAAQ,CAAC2E,KAAK,EAAG,CAAA;AAEtB,QAAA,IAAI/E,OAAO,CAACD,EAAE,IAAI,IAAI,EAAE;AACtBkE,UAAAA,MAAM,CAACxE,MAAM,EAASM,EAAE,CAAC,CAAA;AAC3B,SAAA;AACF,OAAA;AACF,KAAA;AAEA,IAAA,MAAMiF,MAAM,GAAGtC,cAAc,CAACjD,MAAM,EAAS;MAAEM,EAAE;MAAEqB,KAAK;MAAEkB,KAAK;AAAEkC,MAAAA,IAAAA;AAAK,KAAC,CAAC,CAAA;IACxE,MAAM,CAACS,OAAO,CAAC,GAAGC,KAAK,CAACC,IAAI,CAACH,MAAM,CAAC,CAAA;AACpC,IAAA,MAAMI,IAAI,GAAGrC,eAAe,CAACtD,MAAM,EAAS;MAAEM,EAAE;MAAEqB,KAAK;MAAEkB,KAAK;AAAEkC,MAAAA,IAAAA;AAAK,KAAC,CAAC,CAAA;AAEvE,IAAA,IAAI,CAACS,OAAO,IAAI,CAACG,IAAI,EAAE;AACrB,MAAA,OAAA;AACF,KAAA;AAEA,IAAA,MAAM,CAAC3B,IAAI,EAAEnC,IAAI,CAAC,GAAG2D,OAAO,CAAA;AAC5B,IAAA,MAAM,CAACI,QAAQ,EAAEC,QAAQ,CAAC,GAAGF,IAAI,CAAA;IAEjC,IAAI9D,IAAI,CAACqC,MAAM,KAAK,CAAC,IAAI2B,QAAQ,CAAC3B,MAAM,KAAK,CAAC,EAAE;AAC9C,MAAA,OAAA;AACF,KAAA;AAEA,IAAA,MAAM4B,OAAO,GAAGd,IAAI,CAACe,IAAI,CAACF,QAAQ,CAAC,CAAA;IACnC,MAAMG,UAAU,GAAGhB,IAAI,CAACiB,MAAM,CAACpE,IAAI,EAAEgE,QAAQ,CAAC,CAAA;IAC9C,MAAMK,iBAAiB,GAAGlB,IAAI,CAACmB,SAAS,CAACtE,IAAI,EAAEgE,QAAQ,CAAC,CAAA;AACxD,IAAA,MAAMO,OAAO,GAAGhG,MAAM,CAACiG,MAAM,CAACrG,MAAM,EAAS;AAAEM,MAAAA,EAAE,EAAEuB,IAAAA;AAAK,KAAC,CAAC,CAAA;AAC1D,IAAA,MAAMwE,MAAM,GAAG,IAAIC,GAAG,CACpBb,KAAK,CAACC,IAAI,CAACU,OAAO,EAAE,CAAC,CAAC5D,CAAC,CAAC,KAAKA,CAAC,CAAC,CAC5B+D,KAAK,CAACP,UAAU,CAAC9B,MAAM,CAAC,CACxBqC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAChB,CAAC,CAAA;;AAED;AACA;AACA,IAAA,MAAMC,aAAa,GAAG9D,YAAY,CAAC1C,MAAM,EAAS;AAChDM,MAAAA,EAAE,EAAEuB,IAAI;AACRkD,MAAAA,IAAI,EAAE,SAAS;AACfpD,MAAAA,KAAK,EAAGa,CAAC,IAAK6D,MAAM,CAACI,GAAG,CAACjE,CAAC,CAAC,IAAIhB,SAAS,CAACgB,CAAC,CAAC,IAAIuB,cAAc,CAACvB,CAAC,CAAA;AACjE,KAAC,CAAC,CAAA;AAEF,IAAA,MAAMkE,QAAQ,GACZF,aAAa,IAAInG,aAAa,CAACL,MAAM,EAASwG,aAAa,CAAC,CAAC,CAAC,CAAC,CAAA;AACjE,IAAA,IAAIG,UAAU,CAAA;AACd,IAAA,IAAIC,QAAQ,CAAA;;AAEZ;AACA;IACA,IAAI/C,MAAM,CAACG,IAAI,CAAC,IAAIH,MAAM,CAAC+B,QAAQ,CAAC,EAAE;MACpC,MAAM;QAAEiB,IAAI;QAAE,GAAGC,IAAAA;AAAK,OAAC,GAAG9C,IAAI,CAAA;AAC9B4C,MAAAA,QAAQ,GAAGhB,QAAQ,CAACiB,IAAI,CAAC3C,MAAM,CAAA;AAC/ByC,MAAAA,UAAU,GAAGG,IAAqB,CAAA;KACnC,MAAM,IAAItF,SAAS,CAACwC,IAAI,CAAC,IAAIxC,SAAS,CAACoE,QAAQ,CAAC,EAAE;MACjD,MAAM;QAAE3B,QAAQ;QAAE,GAAG6C,IAAAA;AAAK,OAAC,GAAG9C,IAAI,CAAA;AAClC4C,MAAAA,QAAQ,GAAGhB,QAAQ,CAAC3B,QAAQ,CAACC,MAAM,CAAA;AACnCyC,MAAAA,UAAU,GAAGG,IAAwB,CAAA;AACvC,KAAC,MAAM;MACL,MAAM,IAAIC,KAAK,CACZ,CAAA,+BAAA,EAAiClF,IAAK,CAA+DmF,6DAAAA,EAAAA,IAAI,CAACC,SAAS,CAClHjD,IACF,CAAE,CAAA,CAAA,EAAGgD,IAAI,CAACC,SAAS,CAACrB,QAAQ,CAAE,EAChC,CAAC,CAAA;AACH,KAAA;;AAEA;AACA;AACA,IAAA,IACE,CAACM,iBAAiB;AAAI;AACtB,IAAA,CAACtB,SAAS,EACV;MACAN,SAAS,CAACtE,MAAM,EAAE;AAAEM,QAAAA,EAAE,EAAEuB,IAAI;AAAEqF,QAAAA,EAAE,EAAEpB,OAAO;AAAEjD,QAAAA,KAAAA;AAAM,OAAC,CAAC,CAAA;AACrD,KAAA;;AAEA;AACA;AACA,IAAA,IAAI6D,QAAQ,EAAE;AACZ;AACA,MAAA,IAAI7B,mBAAmB,EAAE;AACvB,QAAA,MAAMsC,SAAS,GAAGT,QAAQ,CAAClB,OAAO,CAAA;AAClC2B,QAAAA,SAAS,IAAItC,mBAAmB,CAAC7E,MAAM,EAAS;AAAEM,UAAAA,EAAE,EAAE6G,SAAAA;AAAU,SAAC,CAAC,CAAA;AACpE,OAAC,MAAM;QACL5C,WAAW,CAACvE,MAAM,EAAE;UAAEM,EAAE,EAAEoG,QAAQ,CAAClB,OAAQ;AAAE3C,UAAAA,KAAAA;AAAM,SAAC,CAAC,CAAA;AACvD,OAAA;AACA;AACF,KAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAA,IAAI+B,SAAS,EAAE;MACbA,SAAS,CAAC5E,MAAM,EAAS;AAAEM,QAAAA,EAAE,EAAEuB,IAAI;AAAEqF,QAAAA,EAAE,EAAEpB,OAAAA;AAAQ,OAAC,CAAC,CAAA;AACnD;KACD,MAAM,IACJtE,SAAS,CAACoE,QAAQ,CAAC,IAAIpC,cAAc,CAACxD,MAAM,EAAS4F,QAAQ,CAAC,IAC9D/B,MAAM,CAAC+B,QAAQ,CAAC,IAAIA,QAAQ,CAACiB,IAAI,KAAK,EAAG,EAC1C;MACAtC,WAAW,CAACvE,MAAM,EAAE;AAAEM,QAAAA,EAAE,EAAEuF,QAAQ;AAAEhD,QAAAA,KAAAA;AAAM,OAAC,CAAC,CAAA;AAC9C,KAAC,MAAM;MACL7C,MAAM,CAACoH,KAAK,CAAC;AACXC,QAAAA,IAAI,EAAE,YAAY;AAClBxF,QAAAA,IAAI,EAAEiE,OAAO;QACbc,QAAQ;AACRD,QAAAA,UAAAA;AACF,OAAC,CAAC,CAAA;AACJ,KAAA;AAEA,IAAA,IAAID,QAAQ,EAAE;MACZA,QAAQ,CAACpB,KAAK,EAAE,CAAA;AAClB,KAAA;AACF,GAAC,CAAC,CAAA;AACJ;;AC7LA;AACA;AACA;AACagC,MAAAA,WAAW,GAAGA,CACzBtH,MAAkB,EAClBM,EAAY,KACTF,MAAM,CAACgF,GAAG,CAACpF,MAAM,EAASM,EAAE;;ACJjC;AACA;AACA;MACaiH,WAAW,GAAGA,CACzBvH,MAAkB,EAClBM,EAAY,EACZC,OAA2B,KACTH,MAAM,CAACoH,IAAI,CAACxH,MAAM,EAASM,EAAE,EAAEC,OAAO;;ACT1D;AACA;AACA;MACakH,aAAa,GAAGA,CAC3BzH,MAAkB,EAClBM,EAAY,EACZC,OAA4B,KACzBH,MAAM,CAACsH,KAAK,CAAC1H,MAAM,EAASM,EAAE,EAAEC,OAAO;;ACP5C;AACA;AACA;MACaoH,cAAc,GAAGA,CAC5B3H,MAAkB,EAClBM,EAAY,EACZC,OAA6B,KAC1BH,MAAM,CAACwH,MAAM,CAAC5H,MAAM,EAASM,EAAE,EAAEC,OAAO;;ACP7C;AACA;AACA;AACasH,MAAAA,aAAa,GAAGA,CAC3B7H,MAAkB,EAClBM,EAAY,KACTF,MAAM,CAAC0H,KAAK,CAAC9H,MAAM,EAASM,EAAE;;ACJnC;AACA;AACA;AACayH,MAAAA,WAAW,GAAGA,CACzB/H,MAAkB,EAClBO,OAA2B,KACGH,MAAM,CAAC4H,IAAI,CAAChI,MAAM,EAASO,OAAO;;ACPlE;AACA;AACA;MACa0H,MAAM,GAAGA,CACpBjI,MAAkB,EAClBG,KAAU,KACE;AACZ,EAAA,OAAOqB,SAAS,CAACrB,KAAK,CAAC,IAAIC,MAAM,CAAC6H,MAAM,CAACjI,MAAM,EAASG,KAAK,CAAC,CAAA;AAChE;;ACQO,MAAM+H,WAAW,GAAGA,CACzBlI,MAAkB,EAClBO,OAQC,GAAG,EAAE,KACG;EACTmD,kBAAkB,CAAC1D,MAAM,EAAS,MAAM;IACtC,MAAM;AACJmI,MAAAA,OAAO,GAAG,KAAK;AACfC,MAAAA,IAAI,GAAG,WAAW;AAClBC,MAAAA,QAAQ,GAAG,CAAC;AACZxF,MAAAA,KAAK,GAAG,KAAA;AACV,KAAC,GAAGtC,OAAO,CAAA;IACX,IAAI;MAAED,EAAE,GAAGN,MAAM,CAAC2E,SAAS;AAAEG,MAAAA,OAAO,GAAG,KAAA;AAAM,KAAC,GAAGvE,OAAO,CAAA;IAExD,IAAI,CAACD,EAAE,EAAE;AACP,MAAA,OAAA;AACF,KAAA;AAEA,IAAA,IAAIyC,KAAK,CAACC,OAAO,CAAC1C,EAAE,CAAC,IAAIyC,KAAK,CAACmC,WAAW,CAAC5E,EAAE,CAAC,EAAE;MAC9CA,EAAE,GAAGA,EAAE,CAAC6E,MAAM,CAAA;AAChB,KAAA;AAEA,IAAA,IAAImD,KAAK,CAACC,OAAO,CAACjI,EAAE,CAAC,EAAE;AACrB,MAAA,MAAMkI,YAAY,GAAGT,WAAW,CAAC/H,MAAM,EAAS;QAAEM,EAAE;AAAEyE,QAAAA,IAAI,EAAE,SAAA;AAAU,OAAC,CAAC,CAAA;AAExE,MAAA,IAAI,CAAClC,KAAK,IAAI2F,YAAY,EAAE;AAC1B,QAAA,MAAM,GAAGC,QAAQ,CAAC,GAAGD,YAAY,CAAA;AACjClI,QAAAA,EAAE,GAAGmI,QAAQ,CAAA;AACf,OAAC,MAAM;AACL,QAAA,MAAMC,IAAI,GAAG;UAAEN,IAAI;AAAEC,UAAAA,QAAAA;SAAU,CAAA;AAC/B,QAAA,MAAM5D,MAAM,GAAG0D,OAAO,GAClBR,cAAc,CAAC3H,MAAM,EAASM,EAAE,EAAEoI,IAAI,CAAC,IACvCb,aAAa,CAAC7H,MAAM,EAAS,EAAE,CAAC,GAChCyH,aAAa,CAACzH,MAAM,EAASM,EAAE,EAAEoI,IAAI,CAAC,IACtCpB,WAAW,CAACtH,MAAM,EAAS,EAAE,CAAC,CAAA;AAClCM,QAAAA,EAAE,GAAG;AAAE6E,UAAAA,MAAM,EAAE7E,EAAE;AAAEqI,UAAAA,KAAK,EAAElE,MAAAA;SAAQ,CAAA;AAClCK,QAAAA,OAAO,GAAG,IAAI,CAAA;AAChB,OAAA;AACF,KAAA;AAEA,IAAA,IAAIE,IAAI,CAACC,MAAM,CAAC3E,EAAE,CAAC,EAAE;MACnBiE,WAAW,CAACvE,MAAM,EAAE;QAAEM,EAAE;AAAEuC,QAAAA,KAAAA;AAAM,OAAC,CAAC,CAAA;AAClC,MAAA,OAAA;AACF,KAAA;AAEA,IAAA,IAAIE,KAAK,CAACmC,WAAW,CAAC5E,EAAE,CAAC,EAAE;AACzB,MAAA,OAAA;AACF,KAAA;IAEA,IAAI,CAACwE,OAAO,EAAE;MACZxE,EAAE,GAAGF,MAAM,CAACwC,WAAW,CAAC5C,MAAM,EAASM,EAAE,EAAE;AAAEuC,QAAAA,KAAAA;AAAM,OAAC,CAAC,CAAA;AACvD,KAAA;IAEA,IAAI,CAACiF,KAAK,EAAE1C,GAAG,CAAC,GAAGrC,KAAK,CAACsC,KAAK,CAAC/E,EAAE,CAAC,CAAA;AAClC,IAAA,MAAMsI,UAAU,GAAGlG,YAAY,CAAC1C,MAAM,EAAE;MACtC2B,KAAK,EAAGa,CAAC,IAAKd,OAAO,CAAC1B,MAAM,EAASwC,CAAC,CAAC;AACvClC,MAAAA,EAAE,EAAEwH,KAAK;AACTjF,MAAAA,KAAAA;AACF,KAAC,CAAC,CAAA;AACF,IAAA,MAAMgG,QAAQ,GAAGnG,YAAY,CAAC1C,MAAM,EAAE;MACpC2B,KAAK,EAAGa,CAAC,IAAKd,OAAO,CAAC1B,MAAM,EAASwC,CAAC,CAAC;AACvClC,MAAAA,EAAE,EAAE8E,GAAG;AACPvC,MAAAA,KAAAA;AACF,KAAC,CAAC,CAAA;IACF,MAAMiG,cAAc,GAClBF,UAAU,IAAIC,QAAQ,IAAI,CAAC7D,IAAI,CAAC+D,MAAM,CAACH,UAAU,CAAC,CAAC,CAAC,EAAEC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;AACpE,IAAA,MAAMG,YAAY,GAAGhE,IAAI,CAAC+D,MAAM,CAACjB,KAAK,CAACjG,IAAI,EAAEuD,GAAG,CAACvD,IAAI,CAAC,CAAA;IACtD,MAAMoH,SAAS,GAAGpG,KAAK,GACnB,IAAI,GACJkF,WAAW,CAAC/H,MAAM,EAAS;AAAEM,MAAAA,EAAE,EAAEwH,KAAK;AAAE/C,MAAAA,IAAI,EAAE,SAAA;AAAU,KAAC,CAAC,CAAA;IAC9D,MAAMmE,OAAO,GAAGrG,KAAK,GACjB,IAAI,GACJkF,WAAW,CAAC/H,MAAM,EAAS;AAAEM,MAAAA,EAAE,EAAE8E,GAAG;AAAEL,MAAAA,IAAI,EAAE,SAAA;AAAU,KAAC,CAAC,CAAA;;AAE5D;AACA,IAAA,IAAIkE,SAAS,EAAE;AACb,MAAA,MAAMrB,MAAM,GAAGD,cAAc,CAAC3H,MAAM,EAAS8H,KAAK,CAAC,CAAA;AAEnD,MAAA,IAAIF,MAAM,IAAIgB,UAAU,IAAI5D,IAAI,CAACmE,UAAU,CAACP,UAAU,CAAC,CAAC,CAAC,EAAEhB,MAAM,CAAC/F,IAAI,CAAC,EAAE;AACvEiG,QAAAA,KAAK,GAAGF,MAAM,CAAA;AAChB,OAAA;AACF,KAAA;AAEA,IAAA,IAAIsB,OAAO,EAAE;AACX,MAAA,MAAMxB,KAAK,GAAGD,aAAa,CAACzH,MAAM,EAASoF,GAAG,CAAC,CAAA;AAE/C,MAAA,IAAIsC,KAAK,IAAImB,QAAQ,IAAI7D,IAAI,CAACmE,UAAU,CAACN,QAAQ,CAAC,CAAC,CAAC,EAAEnB,KAAK,CAAC7F,IAAI,CAAC,EAAE;AACjEuD,QAAAA,GAAG,GAAGsC,KAAK,CAAA;AACb,OAAA;AACF,KAAA;;AAEA;AACA;IACA,MAAMnG,OAAqB,GAAG,EAAE,CAAA;AAChC,IAAA,IAAI6H,QAA0B,CAAA;AAE9B,IAAA,MAAM7D,MAAM,GAAGtC,cAAc,CAACjD,MAAM,EAAS;MAAEM,EAAE;AAAEuC,MAAAA,KAAAA;AAAM,KAAC,CAAC,CAAA;AAC3D,IAAA,KAAK,MAAMwG,KAAK,IAAI9D,MAAM,EAAE;AAC1B,MAAA,MAAM,CAACvB,IAAI,EAAEnC,IAAI,CAAC,GAAGwH,KAAK,CAAA;AAE1B,MAAA,IAAID,QAAQ,IAAIpE,IAAI,CAACsE,OAAO,CAACzH,IAAI,EAAEuH,QAAQ,CAAC,KAAK,CAAC,EAAE;AAClD,QAAA,SAAA;AACF,OAAA;AAEA,MAAA,IACG,CAACvG,KAAK,IAAIoF,MAAM,CAACjI,MAAM,EAASgE,IAAI,CAAC,IACrC,CAACgB,IAAI,CAACuE,QAAQ,CAAC1H,IAAI,EAAEiG,KAAK,CAACjG,IAAI,CAAC,IAAI,CAACmD,IAAI,CAACuE,QAAQ,CAAC1H,IAAI,EAAEuD,GAAG,CAACvD,IAAI,CAAE,EACpE;AACAN,QAAAA,OAAO,CAACiI,IAAI,CAACH,KAAY,CAAC,CAAA;AAC1BD,QAAAA,QAAQ,GAAGvH,IAAI,CAAA;AACjB,OAAA;AACF,KAAA;AAEA,IAAA,MAAM4H,QAAQ,GAAGhE,KAAK,CAACC,IAAI,CAACnE,OAAO,EAAE,CAAC,GAAGmI,CAAC,CAAC,KACzCrJ,aAAa,CAACL,MAAM,EAAS0J,CAAC,CAChC,CAAC,CAAA;AACD,IAAA,MAAMC,QAAQ,GAAGlJ,cAAc,CAACT,MAAM,EAAS8H,KAAK,CAAC,CAAA;AACrD,IAAA,MAAM8B,MAAM,GAAGnJ,cAAc,CAACT,MAAM,EAASoF,GAAG,CAAC,CAAA;AAEjD,IAAA,IAAI,CAAC4D,YAAY,IAAI,CAACC,SAAS,EAAE;AAC/B,MAAA,MAAMvI,KAAK,GAAGiJ,QAAQ,CAACnE,OAAQ,CAAA;MAC/B,MAAM,CAACxB,IAAI,CAAC,GAAGuD,WAAW,CAACvH,MAAM,EAASU,KAAK,CAAC,CAAA;MAChD,MAAM;AAAEmB,QAAAA,IAAAA;AAAK,OAAC,GAAGnB,KAAK,CAAA;MACtB,MAAM;AAAEmJ,QAAAA,MAAAA;AAAO,OAAC,GAAG/B,KAAK,CAAA;MACxB,MAAMjB,IAAI,GAAG7C,IAAI,CAAC6C,IAAI,CAACN,KAAK,CAACsD,MAAM,CAAC,CAAA;MACpC7J,MAAM,CAACoH,KAAK,CAAC;AAAEC,QAAAA,IAAI,EAAE,aAAa;QAAExF,IAAI;QAAEgI,MAAM;AAAEhD,QAAAA,IAAAA;AAAK,OAAC,CAAC,CAAA;AAC3D,KAAA;AAEA,IAAA,KAAK,MAAMrG,OAAO,IAAIiJ,QAAQ,EAAE;AAC9B,MAAA,MAAM5H,IAAI,GAAGrB,OAAO,CAAC8E,KAAK,EAAG,CAAA;MAC7Bf,WAAW,CAACvE,MAAM,EAAE;AAAEM,QAAAA,EAAE,EAAEuB,IAAI;AAAEgB,QAAAA,KAAAA;AAAM,OAAC,CAAC,CAAA;AAC1C,KAAA;IAEA,IAAI,CAACqG,OAAO,EAAE;AACZ,MAAA,MAAMxI,KAAK,GAAGkJ,MAAM,CAACpE,OAAQ,CAAA;MAC7B,MAAM,CAACxB,IAAI,CAAC,GAAGuD,WAAW,CAACvH,MAAM,EAASU,KAAK,CAAC,CAAA;MAChD,MAAM;AAAEmB,QAAAA,IAAAA;AAAK,OAAC,GAAGnB,KAAK,CAAA;MACtB,MAAMmJ,MAAM,GAAGb,YAAY,GAAGlB,KAAK,CAAC+B,MAAM,GAAG,CAAC,CAAA;AAC9C,MAAA,MAAMhD,IAAI,GAAG7C,IAAI,CAAC6C,IAAI,CAACN,KAAK,CAACsD,MAAM,EAAEzE,GAAG,CAACyE,MAAM,CAAC,CAAA;MAChD7J,MAAM,CAACoH,KAAK,CAAC;AAAEC,QAAAA,IAAI,EAAE,aAAa;QAAExF,IAAI;QAAEgI,MAAM;AAAEhD,QAAAA,IAAAA;AAAK,OAAC,CAAC,CAAA;AAC3D,KAAA;AAEA,IAAA,IAAI,CAACmC,YAAY,IAAIF,cAAc,IAAIc,MAAM,CAACpE,OAAO,IAAImE,QAAQ,CAACnE,OAAO,EAAE;AACzE;MACAd,UAAU,CAAC1E,MAAM,EAAS;QACxBM,EAAE,EAAEsJ,MAAM,CAACpE,OAAO;AAClBV,QAAAA,OAAO,EAAE,IAAI;AACbjC,QAAAA,KAAAA;AACF,OAAC,CAAC,CAAA;AACJ,KAAA;AAEA,IAAA,MAAMnC,KAAK,GAAGkJ,MAAM,CAACtE,KAAK,EAAE,IAAIqE,QAAQ,CAACrE,KAAK,EAAE,CAAA;AAEhD,IAAA,IAAI/E,OAAO,CAACD,EAAE,IAAI,IAAI,IAAII,KAAK,EAAE;AAC/B8D,MAAAA,MAAM,CAACxE,MAAM,EAASU,KAAK,CAAC,CAAA;AAC9B,KAAA;AACF,GAAC,CAAC,CAAA;AACJ;;ACrLA;AACA;AACA;AACaoJ,MAAAA,aAAa,GAAGA,CAC3B9J,MAAkB,EAClBM,EAAY,KACTF,MAAM,CAACiF,KAAK,CAACrF,MAAM,EAASM,EAAE;;ACLnC;AACA;AACA;AACA;AACA;AACA;AACO,MAAMyJ,eAAe,GAAGA,CAC7B/J,MAAkB,EAClBM,EAA+B,EAC/BC,OAA6B,KAC1B;AACH,EAAA,IAAI,CAACD,EAAE,EAAE,OAAO,EAAE,CAAA;EAElB,IAAI;IACF,OAAOF,MAAM,CAAC4J,MAAM,CAAChK,MAAM,EAASM,EAAE,EAAEC,OAAO,CAAC,CAAA;GACjD,CAAC,OAAO8C,KAAK,EAAE;AACd,IAAA,OAAO,EAAE,CAAA;AACX,GAAA;AACF;;AClBA;AACA;AACA;AACa4G,MAAAA,YAAY,GAAGA,CAC1BjK,MAAkB,EAClBM,EAAY,KACMF,MAAM,CAAC8J,KAAK,CAAClK,MAAM,EAASM,EAAE;;ACNlD;AACA;AACA;AACa6J,MAAAA,WAAW,GAAGA,CACzBnK,MAAkB,EAClBM,EAAY,KACYF,MAAM,CAACgK,QAAQ,CAACpK,MAAM,EAASM,EAAE;;ACN3D;AACA;AACA;AACa+J,MAAAA,WAAW,GAAGA,CACzBrK,MAAkB,EAClBM,EAAY,KACMF,MAAM,CAACkK,IAAI,CAACtK,MAAM,EAASM,EAAE;;ACGjD;AACA;AACA;AACaiK,MAAAA,SAAS,GAAGA,CACvBvK,MAAkB,EAClBO,OAA6B,KAE7BH,MAAM,CAACiG,MAAM,CAACrG,MAAM,EAASO,OAAc;;AChB7C;AACA;AACA;AACO,MAAMiK,QAAQ,GAAqBxK,MAAkB,IAC1DI,MAAM,CAACqK,KAAK,CAACzK,MAAa;;ACM5B;AACA;AACA;AACa0K,MAAAA,WAAW,GAAGA,CACzB1K,MAAkB,EAClBO,OAA+B,KAE/BH,MAAM,CAAC2F,IAAI,CAAC/F,MAAM,EAASO,OAAc;;AChB3C;AACA;AACA;AACO,MAAMoK,YAAY,GAAGA,CAC1B3K,MAAkB,EAClBM,EAAY,EACZC,OAA2B,KACG;EAC9B,IAAI;IACF,OAAOH,MAAM,CAAC4D,IAAI,CAAChE,MAAM,EAASM,EAAE,EAAEC,OAAO,CAAC,CAAA;AAChD,GAAC,CAAC,OAAO8C,KAAK,EAAE,EAAC;AACnB;;ACbA;AACA;AACA;MACauH,OAAO,GAAGA,CACrB5K,MAAkB,EAClBM,EAAY,EACZC,OAA2B,KACxBH,MAAM,CAACyB,IAAI,CAAC7B,MAAM,EAASM,EAAE,EAAEC,OAAc;;ACPlD;AACA;AACA;AACO,MAAMsK,WAAW,GAAqB7K,MAAkB,IAC7DI,MAAM,CAACqJ,QAAQ,CAACzJ,MAAa;;ACJ/B;AACA;AACA;MACa8K,QAAQ,GAAGA,CACtB9K,MAAkB,EAClBM,EAAY,EACZC,OAA4B,KACzBH,MAAM,CAACM,KAAK,CAACV,MAAM,EAASM,EAAE,EAAEC,OAAO;;ACP5C;AACA;AACA;AACO,MAAMwK,YAAY,GAAqB/K,MAAkB,IAC9DI,MAAM,CAAC4K,SAAS,CAAChL,MAAa;;ACJhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACaiL,MAAAA,YAAY,GAAGA,CAC1BjL,MAAkB,EAClBO,OAAgC,KAC7BH,MAAM,CAAC8K,SAAS,CAAClL,MAAM,EAASO,OAAO;;ACf5C;AACA;AACA;MACa4K,QAAQ,GAAGA,CACtBnL,MAAkB,EAClBM,EAAY,EACZ4G,EAAa,KACV9G,MAAM,CAACS,KAAK,CAACb,MAAM,EAASM,EAAE,EAAE4G,EAAE;;ACPvC;AACA;AACA;AACO,MAAMkE,YAAY,GAAqBpL,MAAkB,IAC9DI,MAAM,CAACiL,SAAS,CAACrL,MAAa;;ACHhC;AACA;AACA;AACasL,MAAAA,SAAS,GAAGA,CACvBtL,MAAkB,EAClBoB,OAAiB,KACdhB,MAAM,CAACkL,SAAS,CAACtL,MAAM,EAASoB,OAAO;;ACN5C;AACA;AACA;AACamK,MAAAA,UAAU,GAAGA,CACxBvL,MAAkB,EAClBoB,OAAiB,KACdhB,MAAM,CAACmL,UAAU,CAACvL,MAAM,EAASoB,OAAO;;ACN7C;AACA;AACA;AACaoK,MAAAA,QAAQ,GAAGA,CACtBxL,MAAkB,EAClBoB,OAAiB,KACdhB,MAAM,CAACoL,QAAQ,CAACxL,MAAM,EAASoB,OAAO;;ACP3C;AACA;AACA;AACA;AACA;AACO,MAAMqK,WAAW,GAAqBzL,MAAkB,IAC7DI,MAAM,CAACqL,WAAW,CAACzL,MAAa;;ACLlC;AACA;AACA;AACA;AACA;AACa0L,MAAAA,UAAU,GAAGA,CACxB1L,MAAkB,EAClBgE,IAA6C,KAC1C5D,MAAM,CAACsL,UAAU,CAAC1L,MAAM,EAASgE,IAAW;;ACTjD;AACA;AACA;MACa2H,WAAW,GAAGA,CACzB3L,MAAkB,EAClBU,KAAY,EACZJ,EAAY,KACTF,MAAM,CAACwL,MAAM,CAAC5L,MAAM,EAASU,KAAK,EAAEJ,EAAE;;ACP3C;AACA;AACA;AACO,MAAMuL,QAAQ,GAAI1L,KAAU,IACjCC,MAAM,CAACyL,QAAQ,CAAC1L,KAAK;;ACJvB;AACA;AACA;AACO,MAAM2L,mBAAmB,GAAqB9L,MAAkB,IACrEI,MAAM,CAAC2L,aAAa,CAAC/L,MAAa;;ACJpC;AACA;AACA;AACA;AACO,MAAMgM,UAAU,GAAGA,CACxBhM,MAAkB,EAClBU,KAA+B,EAC/BJ,EAAY,KACT,CAAC,CAACI,KAAK,IAAIN,MAAM,CAAC6L,KAAK,CAACjM,MAAM,EAASU,KAAK,EAAEJ,EAAE;;ACPrD;AACA;AACA;AACO,MAAM4L,QAAQ,GAAGA,CACtBlM,MAAkB,EAClBG,KAAU,KACEqB,SAAS,CAACrB,KAAK,CAAC,IAAIC,MAAM,CAAC8L,QAAQ,CAAClM,MAAM,EAASG,KAAK;;ACPtE;AACA;AACA;AACA;AACO,MAAMgM,YAAY,GAAGA,CAC1BnM,MAAkB,EAClBU,KAA+B,EAC/BJ,EAAY,KACT,CAAC,CAACI,KAAK,IAAIN,MAAM,CAACgM,OAAO,CAACpM,MAAM,EAASU,KAAK,EAAEJ,EAAE;;ACTvD;AACA;AACA;MACa+L,cAAc,GAAGA,CAC5BrM,MAAkB,EAClBG,KAAU,KACE;EACZ,OAAOqB,SAAS,CAACrB,KAAK,CAAC,IAAIH,MAAM,CAACsM,YAAY,CAACnM,KAAK,CAAC,CAAA;AACvD;;ACPA;AACA;AACA;AACaoM,MAAAA,eAAe,GAAGA,CAC7BvM,MAAkB,EAClBO,OAAgC,KAC7BH,MAAM,CAACoM,SAAS,CAACxM,MAAM,EAASO,OAAO;;ACN5C;AACA;AACA;AACA;AACA;AACA;AACA;AACakM,MAAAA,gBAAgB,GAAGA,CAC9BzM,MAAkB,EAClBE,GAAW,KACRE,MAAM,CAACsM,UAAU,CAAC1M,MAAM,EAASE,GAAG;;ACVzC;AACA;AACA;AACO,MAAMyM,eAAe,GAAIxM,KAAU,IACxCyM,aAAa,CAACD,eAAe,CAACxM,KAAY;;ACH5C;AACA;AACA;AACO,MAAM0M,gBAAgB,GAAqB7M,MAAyB,IACzE4M,aAAa,CAACE,SAAS,CAAC9M,MAAa;;ACJvC;AACA;AACA;AACO,MAAM+M,eAAe,GAAqB/M,MAAyB,IACxE4M,aAAa,CAACI,QAAQ,CAAChN,MAAa;;ACJtC;AACA;AACA;AACaiN,MAAAA,qBAAqB,GAAGA,CACnCjN,MAAyB,EACzB2D,EAAc,KACXiJ,aAAa,CAACM,cAAc,CAAClN,MAAM,EAAS2D,EAAE;;ACNnD;AACA;AACA;AACawJ,MAAAA,oBAAoB,GAAGA,CAClCnN,MAAyB,EACzB2D,EAAc,KACXiJ,aAAa,CAACQ,aAAa,CAACpN,MAAM,EAAS2D,EAAE;;ACJlD;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAOA;AACA;AACA;;AAUa0J,MAAAA,YAAkD,GAC7DrJ,IAAS,IACNxC,SAAS,CAACwC,IAAI,CAAC,IAAIH,MAAM,CAACG,IAAI;;ACrCnC;AACA;AACA;MACasJ,aAAa,GAAGA,CAC3BC,IAAO,EACP1L,IAAU,EACV2L,OAAa,KACVC,IAAI,CAACxH,MAAM,CAACsH,IAAI,EAAE1L,IAAI,EAAE2L,OAAO;;ACRpC;AACA;AACA;AACO,MAAME,UAAU,GAAIvN,KAAU,IACnC2D,IAAI,CAAC4J,UAAU,CAACvN,KAAK;;ACJvB;AACA;AACA;AACawN,MAAAA,UAAU,GAAGA,CAAC9G,IAAW,EAAE2G,OAAc,KACpD1J,IAAI,CAACiF,MAAM,CAAClC,IAAI,EAAE2G,OAAO;;ACJ3B;AACA;AACA;AACA;AACA;AACA;AACaI,MAAAA,WAAW,GAAGA,CAAkB/G,IAAO,EAAExF,KAAa,KACjEyC,IAAI,CAACvC,OAAO,CAACsF,IAAI,EAAExF,KAAK;;ACN1B;AACA;AACA;AACA;AACA;AACA;AACA;MACawM,OAAO,GAAGA,CACrBN,IAAO,EACP1L,IAAU,KACP;EACH,IAAI;AACF,IAAA,KAAK,IAAIiM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjM,IAAI,CAACqC,MAAM,EAAE4J,CAAC,EAAE,EAAE;AACpC,MAAA,MAAMpE,CAAC,GAAG7H,IAAI,CAACiM,CAAC,CAAC,CAAA;AAEjB,MAAA,IAAIjK,MAAM,CAAC0J,IAAI,CAAC,IAAI,CAACA,IAAI,CAACtJ,QAAQ,CAACyF,CAAC,CAAC,EAAE;AACrC,QAAA,OAAO,IAAI,CAAA;AACb,OAAA;AAEA6D,MAAAA,IAAI,GAAGA,IAAI,CAACtJ,QAAQ,CAACyF,CAAC,CAAM,CAAA;AAC9B,KAAA;AAEA,IAAA,OAAO6D,IAAI,CAAA;GACZ,CAAC,OAAOlK,KAAK,EAAE;AACd,IAAA,OAAO,IAAI,CAAA;AACb,GAAA;AACF;;AC1BA;AACA;AACA;AACa0K,MAAAA,eAAe,GAAGA,CAI7BR,IAAO,EACP1L,IAAU,KACP4L,IAAI,CAACO,QAAQ,CAACT,IAAI,EAAE1L,IAAI;;ACR7B;AACA;AACA;AACA;AACA;AACA;MACaoM,gBAAgB,GAAGA,CAI9BV,IAAO,EACP1L,IAAU,EACVtB,OAA8B,KAE9BkN,IAAI,CAACS,SAAS,CAACX,IAAI,EAAE1L,IAAI,EAAEtB,OAAO;;ACfpC;AACA;AACA;AACa4N,MAAAA,YAAY,GAAGA,CAK1BZ,IAAO,EACPa,KAAQ,KACLX,IAAI,CAACY,KAAK,CAACd,IAAI,EAAEa,KAAK;;ACT3B;AACA;AACA;MACaE,eAAe,GAAGA,CAC7Bf,IAAO,EACP1L,IAAU,EACVtB,OAA6B,KAE7BkN,IAAI,CAACxJ,QAAQ,CAACsJ,IAAI,EAAE1L,IAAI,EAAEtB,OAAO;;ACTnC;AACA;AACA;AACagO,MAAAA,iBAAiB,GAAGA,CAI/BhB,IAAO,EACP1L,IAAU,KACP4L,IAAI,CAACe,UAAU,CAACjB,IAAI,EAAE1L,IAAI;;ACP/B;AACA;AACA;AACa4M,MAAAA,kBAAkB,GAAGA,CAIhClB,IAAO,EACPhN,OAKC,KAEDkN,IAAI,CAACiB,WAAW,CAACnB,IAAI,EAAEhN,OAAc;;ACfvC;AACA;AACA;AACA;AACA;AACaoO,MAAAA,eAAe,GAAGA,CAI7BpB,IAAO,EACPhN,OAKC,KAEDkN,IAAI,CAACmB,QAAQ,CAACrB,IAAI,EAAEhN,OAAc;;ACnBpC;AACA;AACA;AACasO,MAAAA,gBAAgB,GAAGA,CAC9BtB,IAAO,EACP1L,IAAU,KACP4L,IAAI,CAACvD,KAAK,CAACqD,IAAI,EAAE1L,IAAI;;ACL1B;AACA;AACA;AACaiN,MAAAA,eAAe,GAAGA,CAI7BvB,IAAO,EACP1M,KAAY,KACT4M,IAAI,CAACrD,QAAQ,CAACmD,IAAI,EAAE1M,KAAK;;ACV9B;AACA;AACA;AACakO,MAAAA,eAAe,GAAGA,CAC7BxB,IAAO,EACP1L,IAAU,KACP4L,IAAI,CAACnD,IAAI,CAACiD,IAAI,EAAE1L,IAAI;;ACNzB;AACA;AACA;AACamN,MAAAA,WAAW,GAAGA,CACzBzB,IAAO,EACP1L,IAAU,KACP4L,IAAI,CAACjG,IAAI,CAAC+F,IAAI,EAAE1L,IAAI;;ACNzB;AACA;AACA;AACA;AACA;AACA;MACaoN,aAAa,GAAGA,CAC3B1B,IAAO,EACP1L,IAAU,EACVtB,OAA2B,KAE3BkN,IAAI,CAACpH,MAAM,CAACkH,IAAI,EAAE1L,IAAI,EAAEtB,OAAO;;ACXjC;AACA;AACA;AACa2O,MAAAA,aAAa,GAAGA,CAC3B3B,IAAO,EACP1L,IAAU,KACP4L,IAAI,CAACrK,MAAM,CAACmK,IAAI,EAAE1L,IAAI;;ACP3B;AACA;AACA;AACO,MAAMsN,YAAY,GAAqBnL,IAAO,IACnDyJ,IAAI,CAAC2B,YAAY,CAACpL,IAAI;;ACJxB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMqL,aAAa,GAAIrL,IAAW,IAAKyJ,IAAI,CAACzD,MAAM,CAAChG,IAAI;;ACJ9D;AACA;AACA;AACasL,MAAAA,YAAY,GAAGA,CAC1B/B,IAAO,EACPhN,OAKC,KAEDkN,IAAI,CAAC8B,KAAK,CAAChC,IAAI,EAAEhN,OAAc;;ACbjC;AACA;AACA;AACA;AACA;AACaiP,MAAAA,QAAQ,GAAGA,CACtBjC,IAAO,EACPhN,OAKC,KAEDkN,IAAI,CAACvK,KAAK,CAACqK,IAAI,EAAEhN,OAAc;;AChBjC;AACA;AACA;AACakP,MAAAA,OAAO,GAAGA,CAAClC,IAAW,EAAE1L,IAAU,KAAK4L,IAAI,CAAChH,GAAG,CAAC8G,IAAI,EAAE1L,IAAI;;ACHvE;AACA;AACA;AACO,MAAMsH,UAAU,GAAIhJ,KAAU,IACnCmB,OAAO,CAAC6H,UAAU,CAAChJ,KAAK;;ACJ1B;AACA;AACA;AACO,MAAMuP,MAAM,GAAIvP,KAAU,IAAqBsN,IAAI,CAACiC,MAAM,CAACvP,KAAK;;ACHvE;AACA;AACA;AACO,MAAMwP,UAAU,GAAIxP,KAAU,IACnCsN,IAAI,CAACkC,UAAU,CAACxP,KAAK;;ACJvB;AACA;AACA;AACayP,MAAAA,WAAW,GAAGA,CAAC5L,IAAW,EAAE3C,KAAa,KACpDoM,IAAI,CAAClM,OAAO,CAACyC,IAAI,EAAE3C,KAAK;;ACN1B;AACA;AACA;AACA;AACa6D,MAAAA,WAAW,GAAIrE,KAAoB,IAC9C,CAAC,CAACA,KAAK,IAAIkC,KAAK,CAACmC,WAAW,CAACrE,KAAK;;ACLpC;AACA;AACA;AACA;AACagP,MAAAA,UAAU,GAAIhP,KAAoB,IAC7C,CAAC,CAACA,KAAK,IAAIkC,KAAK,CAAC8M,UAAU,CAAChP,KAAK;;ACFnC;AACA;AACA;MACaiP,iBAAiB,GAAGA,CAC/B9P,MAAkB,EAClBO,OAAkC,KAC/B;AACH6D,EAAAA,UAAU,CAAC2L,QAAQ,CAAC/P,MAAM,EAASO,OAAO,CAAC,CAAA;AAC7C;;ACTA;AACA;AACA;AACayP,MAAAA,QAAQ,GAAqBhQ,MAAkB,IAAK;AAC/DoE,EAAAA,UAAU,CAAC4L,QAAQ,CAAChQ,MAAa,CAAC,CAAA;AACpC;;ACHA;AACA;AACA;AACO,MAAMiQ,cAAc,GAAGA,CAI5BjQ,MAAkB,EAClBoK,QAAa,EACb7J,OAAmC,KAChC;EACH6D,UAAU,CAAC6L,cAAc,CAACjQ,MAAM,EAASoK,QAAQ,EAAE7J,OAAO,CAAC,CAAA;AAC7D;;ACHA;AACA;AACA;AACO,MAAM2P,WAAW,GAAGA,CAIzBlQ,MAAkB,EAClBkD,KAAc,EACd3C,OAA+B,KAC5B;AACH,EAAA,IAAIA,OAAO,KAAPA,IAAAA,IAAAA,OAAO,eAAPA,OAAO,CAAE4P,SAAS,EAAE;AACtB,IAAA,MAAM7P,EAAE,GAAG,CAAAC,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAED,EAAE,KAAIN,MAAM,CAAC2E,SAAS,CAAA;AAC1C,IAAA,IAAIrE,EAAE,EAAE;AACN,MAAA,MAAM8P,QAAQ,GAAG9I,WAAW,CAACtH,MAAM,EAAEM,EAAE,CAAC,CAAA;AACxC,MAAA,MAAM+P,UAAU,GAAG3N,YAAY,CAAC1C,MAAM,EAAE;AACtCM,QAAAA,EAAE,EAAE8P,QAAQ;AACZ7N,QAAAA,KAAK,EAAE,IAAA;AACT,OAAC,CAAC,CAAA;AACF,MAAA,IAAI8N,UAAU,EAAE;QACd,MAAMC,QAAQ,GAAGtL,IAAI,CAACe,IAAI,CAACsK,UAAU,CAAC,CAAC,CAAC,CAAC,CAAA;QACzC9P,OAAO,CAACD,EAAE,GAAGgQ,QAAQ,CAAA;AACvB,OAAA;AACF,KAAA;AACF,GAAA;EAEAlM,UAAU,CAAC8L,WAAW,CAAClQ,MAAM,EAASkD,KAAK,EAAE3C,OAAc,CAAC,CAAA;AAC9D;;ACrCA;AACA;AACA;AACO,MAAMgQ,UAAU,GAAGA,CACxBvQ,MAAkB,EAClB6G,IAAY,EACZtG,OAA+B,KAC5B;EACH6D,UAAU,CAACmM,UAAU,CAACvQ,MAAM,EAAS6G,IAAI,EAAEtG,OAAO,CAAC,CAAA;AACrD;;ACHA;AACA;AACA;AACA;AACaiQ,MAAAA,SAAS,GAAGA,CACvBxQ,MAAkB,EAClBO,OAA6B,KAC1B6D,UAAU,CAACoM,SAAS,CAACxQ,MAAM,EAASO,OAAc;;ACbvD;AACA;AACA;MACakQ,aAAa,GAAGA,CAC3BzQ,MAAkB,EAClBO,OAA8B,KAC3B;AACH6D,EAAAA,UAAU,CAACsM,IAAI,CAAC1Q,MAAM,EAASO,OAAO,CAAC,CAAA;AACzC;;ACDA;AACA;AACA;MACaoQ,QAAQ,GAAGA,CACtB3Q,MAAkB,EAClBqB,KAA6B,EAC7Bd,OAA4B,KACzB6D,UAAU,CAACuM,QAAQ,CAAC3Q,MAAM,EAASqB,KAAK,EAAEd,OAAc;;ACd7D;AACA;AACA;AACO,MAAMqQ,QAAQ,GAAGA,CACtB5Q,MAAkB,EAClBqB,KAAqB,EACrBd,OAAkC,KAC/B;EACH6D,UAAU,CAACwM,QAAQ,CAAC5Q,MAAM,EAASqB,KAAK,EAAEd,OAAO,CAAC,CAAA;AACpD;;ACVA;AACA;AACA;MACasQ,YAAY,GAAGA,CAC1B7Q,MAAkB,EAClBqB,KAAqB,KAClB;AACH+C,EAAAA,UAAU,CAACyM,YAAY,CAAC7Q,MAAM,EAASqB,KAAK,CAAC,CAAA;AAC/C;;ACDA;AACA;AACA;AACayP,MAAAA,UAAU,GAAGA,CACxB9Q,MAAkB,EAClBO,OAA8B,KAC3B6D,UAAU,CAAC0M,UAAU,CAAC9Q,MAAM,EAASO,OAAc;;ACLxD;AACA;AACA;AACO,MAAMwQ,UAAU,GAAGA,CACxB/Q,MAAkB,EAClBqB,KAAoD,EACpDd,OAA8B,KAC3B;EACH,OAAO6D,UAAU,CAAC2M,UAAU,CAAC/Q,MAAM,EAASqB,KAAK,EAASd,OAAc,CAAC,CAAA;AAC3E;;ACVA;AACA;AACA;AACA;MACayQ,WAAW,GAAGA,CACzBhR,MAAkB,EAClBO,OAA+B,KAC5B;EACH6D,UAAU,CAAC4M,WAAW,CAAChR,MAAM,EAASqC,eAAe,CAACrC,MAAM,EAAEO,OAAO,CAAC,CAAC,CAAA;AACzE;;ACPA;AACA;AACA;AACA;AACO,MAAM0Q,SAAS,GAAGA,CACvBjR,MAAkB,EAClBoB,OAAU,EACVb,OAA6B,KAC1B;AACHqC,EAAAA,WAAW,CAAC5C,MAAM,EAAEO,OAAO,KAAPA,IAAAA,IAAAA,OAAO,KAAPA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAED,EAAE,EAAEC,OAAO,CAAC,CAAA;EAEzC6D,UAAU,CAAC6M,SAAS,CAACjR,MAAM,EAASoB,OAAO,EAASb,OAAc,CAAC,CAAA;AACrE;;ACpBA;AACA;AACA;AACa2Q,MAAAA,SAAS,GAAGA,CACvB7H,KAAqB,EACrB;EAAE8H,MAAM;EAAEC,KAAK;EAAEC,OAAO;EAAEC,KAAK;AAAEC,EAAAA,QAAAA;AAA2B,CAAC,GAAG,EAAE,KAC/D;AACH,EAAA,IAAI,CAAClI,KAAK,EAAE,OAAO,KAAK,CAAA;AAExB,EAAA,MAAM,CAACrF,IAAI,EAAEnC,IAAI,CAAC,GAAGwH,KAAK,CAAA;AAE1B,EAAA,IAAIiI,KAAK,EAAE;AACT,IAAA,MAAMjL,MAAM,GAAGmL,WAAS,CAACF,KAAK,CAAC,CAAA;IAE/B,IAAI,CAACjL,MAAM,CAACjE,QAAQ,CAACP,IAAI,CAACqC,MAAM,CAAC,EAAE;AACjC,MAAA,OAAO,KAAK,CAAA;AACd,KAAA;AACF,GAAA;AAEA,EAAA,IAAIqN,QAAQ,IAAI1P,IAAI,CAACqC,MAAM,GAAGqN,QAAQ,EAAE;AACtC,IAAA,OAAO,KAAK,CAAA;AACd,GAAA;AAEA,EAAA,IAAIJ,MAAM,IAAI,CAACA,MAAM,CAAC9H,KAAK,CAAC,EAAE;AAC5B,IAAA,OAAO,KAAK,CAAA;AACd,GAAA;AAEA,EAAA,IAAI+H,KAAK,EAAE;AACT,IAAA,MAAMK,MAAM,GAAGD,WAAS,CAACJ,KAAK,CAAC,CAAA;AAE/B,IAAA,IAAIK,MAAM,CAACvN,MAAM,GAAG,CAAC,IAAI,CAACuN,MAAM,CAACrP,QAAQ,CAAC4B,IAAI,CAACqD,IAAW,CAAC,EAAE;AAC3D,MAAA,OAAO,KAAK,CAAA;AACd,KAAA;AACF,GAAA;AAEA,EAAA,IAAIgK,OAAO,EAAE;AACX,IAAA,MAAMK,QAAQ,GAAGF,WAAS,CAACH,OAAO,CAAC,CAAA;AAEnC,IAAA,IAAIK,QAAQ,CAACxN,MAAM,GAAG,CAAC,IAAIwN,QAAQ,CAACtP,QAAQ,CAAC4B,IAAI,CAACqD,IAAW,CAAC,EAAE;AAC9D,MAAA,OAAO,KAAK,CAAA;AACd,KAAA;AACF,GAAA;AAEA,EAAA,OAAO,IAAI,CAAA;AACb;;ACrCA;AACA;AACA;AACO,MAAMsK,QAAQ,GAAGA,CACtB3R,MAAkB,EAClBO,OAA2B,GAAG,EAAE,KACF;AAC9B;EACA,IAAI;AACF,IAAA,MAAMqR,WAAW,GAAG3O,cAAc,CAAOjD,MAAM,EAAE;AAC/CM,MAAAA,EAAE,EAAEN,MAAM,CAAC2E,SAAS,IAAI,EAAE;AAC1B,MAAA,GAAGtC,eAAe,CAACrC,MAAM,EAAEO,OAAO,CAAA;AACpC,KAAC,CAAC,CAAA;;AAEF;IACA,KAAK,MAAM,CAACyD,IAAI,EAAEnC,IAAI,CAAC,IAAI+P,WAAW,EAAE;AACtC,MAAA,OAAO,CAAC5N,IAAI,EAAEnC,IAAI,CAAC,CAAA;AACrB,KAAA;GACD,CAAC,OAAOwB,KAAK,EAAE;AACd,IAAA,OAAOZ,SAAS,CAAA;AAClB,GAAA;AACF;;AC9BA;AACA;AACA;AACA;MACaoP,QAAQ,GAAGA,CACtB7R,MAAkB,EAClBO,OAA2B,KACxB;AACH,EAAA,OAAO,CAAC,CAACoR,QAAQ,CAAO3R,MAAM,EAAEO,OAAO,CAAC,CAAA;AAC1C;;ACPA;AACA;AACA;MACauR,aAAa,GAAGA,CAC3B9R,MAAkB,EAClBqB,KAAU,EACV;EACEf,EAAE,GAAGN,MAAM,CAAC2E,SAAAA;AAGd,CAAC,GAAG,EAAE,KACH;AACH,EAAA,IAAIrE,EAAE,EAAE;AACN,IAAA,IAAI0E,IAAI,CAACC,MAAM,CAAC3E,EAAE,CAAC,EAAE;AACnBA,MAAAA,EAAE,GAAG6K,QAAQ,CAACnL,MAAM,EAASM,EAAE,CAAC,CAAA;AAClC,KAAA;AAEA,IAAA,MAAMqB,KAAK,GAAGA,CAACqC,IAAU,EAAEnC,IAAU,KAAK;AACxC,MAAA,IAAI,CAACiC,IAAI,CAACD,MAAM,CAACG,IAAI,CAAC,EAAE;QACtB,OAAO,KAAK,CAAC;AACf,OAAA;;MACA,MAAM+N,WAAW,GAAG3R,MAAM,CAACgD,MAAM,CAACpD,MAAM,EAAS6B,IAAI,CAAC,CAAA;AACtD,MAAA,IAAI,CAACkQ,WAAW,EAAE,OAAO,KAAK,CAAA;AAE9B,MAAA,MAAM,CAACC,UAAU,CAAC,GAAGD,WAAW,CAAA;AAEhC,MAAA,OACE,CAAC/R,MAAM,CAACiI,MAAM,CAAC+J,UAAiB,CAAC,IACjChS,MAAM,CAACsM,YAAY,CAAC0F,UAAiB,CAAC,CAAA;KAEzC,CAAA;AACD,IAAA,MAAMC,eAAe,GAAGlP,KAAK,CAAC8M,UAAU,CAACvP,EAAW,CAAC,CAAA;IACrD,IAAI4R,yBAAyB,GAAG,KAAK,CAAA;IACrC,IAAI,CAACD,eAAe,EAAE;MACpB,MAAME,aAAa,GAAG/R,MAAM,CAAC4D,IAAI,CAAChE,MAAM,EAASM,EAAE,CAAC,CAAA;MACpD,IAAI,CAAC6R,aAAa,EAAE,OAAA;AAEpB,MAAA,MAAM,CAACC,YAAY,EAAEC,YAAY,CAAC,GAAGF,aAAa,CAAA;MAElD,IAAIC,YAAY,IAAIzQ,KAAK,CAACyQ,YAAY,EAAEC,YAAY,CAAC,EAAE;QACrD,MAAMN,WAAW,GAAG3R,MAAM,CAACgD,MAAM,CAACpD,MAAM,EAASqS,YAAY,CAAC,CAAA;QAC9D,IAAI,CAACN,WAAW,EAAE,OAAA;AAElB,QAAA,MAAM,CAACC,UAAU,CAAC,GAAGD,WAAW,CAAA;QAEhCG,yBAAyB,GACvBF,UAAU,IAAIhS,MAAM,CAACsM,YAAY,CAAC0F,UAAiB,CAAC,CAAA;AACxD,OAAA;AACF,KAAA;IACA,IAAIC,eAAe,IAAIC,yBAAyB,EAAE;AAChD9N,MAAAA,UAAU,CAACuM,QAAQ,CAAC3Q,MAAM,EAASqB,KAAK,EAAE;QACxCM,KAAK;AACL2Q,QAAAA,KAAK,EAAE,IAAI;AACXzP,QAAAA,KAAK,EAAE,IAAI;AACXvC,QAAAA,EAAAA;AACF,OAAC,CAAC,CAAA;AACJ,KAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACF,GAAA;AACF;;MCvEaiS,WAAW,GAAGA,CACzBvS,MAAkB,EAClBqB,KAAoC,EACpCd,OAAyB,KACtBoQ,QAAQ,CAAW3Q,MAAM,EAAEqB,KAAK,EAAEd,OAAO;;ACH9C;AACA;AACA;MACaiS,oBAAoB,GAAGA,CAClCxS,MAAkB,EAClBM,EAAS,KACN;EACH,IAAI,CAACwH,KAAK,EAAE1C,GAAG,CAAC,GAAGrC,KAAK,CAACsC,KAAK,CAAC/E,EAAE,CAAC,CAAA;AAElC,EAAA,IAAI,CAAC0E,IAAI,CAAC+D,MAAM,CAACjB,KAAK,CAACjG,IAAI,EAAEuD,GAAG,CAACvD,IAAI,CAAC,EAAE;AACtC,IAAA,IAAIuD,GAAG,CAACyE,MAAM,KAAK,CAAC,EAAE;AACpB,MAAA,MAAM4I,UAAU,GAAGhL,aAAa,CAACzH,MAAM,EAAE8H,KAAK,CAAC,CAAA;AAC/C,MAAA,IAAI2K,UAAU,EAAE;AACdrN,QAAAA,GAAG,GAAGqN,UAAU,CAAA;AAClB,OAAA;AACF,KAAC,MAAM;AACL,MAAA,MAAMC,WAAW,GAAG/K,cAAc,CAAC3H,MAAM,EAAEoF,GAAG,CAAC,CAAA;AAC/C,MAAA,IAAIsN,WAAW,EAAE;AACf5K,QAAAA,KAAK,GAAG4K,WAAW,CAAA;AACrB,OAAA;AACF,KAAA;AACF,GAAA;EAEA,OAAO;AAAEvN,IAAAA,MAAM,EAAE2C,KAAK;AAAEa,IAAAA,KAAK,EAAEvD,GAAAA;GAAK,CAAA;AACtC;;;;","x_google_ignoreList":[9,10]}